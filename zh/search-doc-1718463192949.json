{"searchDocs":[{"title":"Touying 0.2.0","type":0,"sectionRef":"#","url":"/touying/zh/blog/touying-0-2-0","content":"","keywords":"","version":null},{"title":"Implemented Features​","type":1,"pageTitle":"Touying 0.2.0","url":"/touying/zh/blog/touying-0-2-0#implemented-features","content":"  Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods. Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages. #pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list. #pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..]. #meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter. #pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations. Slides: Create simple slides using standard headings. Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s). Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s). Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..). Appendix: Freeze the last-slide-number to prevent the slide number from increasing further. Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection. states.current-section-title to get the current section. states.touying-outline or s.methods.touying-outline to display a outline of sections. states.touying-final-sections(sections =&gt; ..) for custom outline display. states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme. Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":null,"tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/build-your-own-theme","content":"创建自己的主题 您可以参考 主题的源代码，主要需要实现的就是： 自定义颜色主题，即修改 self.colors。自定义 header；自定义 footer;自定义 alert 函数，可选；自定义 slide 函数；自定义特殊 slide 函数，如 title-slide 和 focus-slide 函数；自定义 slide-in-slides 函数，该函数会被 slides 函数调用；自定义 slides 函数，可选；自定义 register 函数，初始化全局单例 s；自定义 init 函数，可选。 待补充更详细的文档。","keywords":"","version":"0.2.x"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/complex","content":"","keywords":"","version":"0.2.x"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.2.x/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的 styled 与 layout 限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) In subslide #self.subslide, test #uncover(&quot;2-&quot;)[uncover] function, and test #only(&quot;2-&quot;)[only] function, #pause and paused text. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.2.x","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.2.x/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.2.x","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.2.x/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.2.x","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.2.x/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.2.x","tagName":"h2"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/changelog","content":"","keywords":"","version":"0.2.x"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.2.x/changelog#v021","content":" ","version":"0.2.x","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.2.x/changelog#features","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.2.x","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.2.x/changelog#fix","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.2.x","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.2.x/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.2.x","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/cover","content":"","keywords":"","version":"0.2.x"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.2.x/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.2.x","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.2.x/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.2.x","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.2.x/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.2.x","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.2.x"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/simple","content":"","keywords":"","version":"0.2.x"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.2.x/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.2.x","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.2.x/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.2.x","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.2.x/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了 set-show rules，你会惊讶的发现，在那之后的 #pause 和 #meanwhile 都失效了。这是因为 Touying 无法探知 styled(..) 内部的内容（set-show rules 后的内容会被 styled 囊括起来）。  为了解决这个问题，Touying 为 #slide() 函数提供了一个 setting 参数，你可以将你的 set-show rules 放到 setting 参数里，例如修改字体颜色：  #slide(setting: body =&gt; { set text(fill: blue) body })[ First #pause Second ]     同理，Touying 目前也不支持 grid 这类 layout 函数内部的 #pause 和 #meanwhile，也是由于同样的限制，但是你可以使用 #slide() 的 composer 参数，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.2.x","tagName":"h2"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/equation","content":"","keywords":"","version":"0.2.x"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.2.x/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.2.x","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.2.x/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.2.x","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.2.x/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.2.x","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/external/pdfpc","content":"","keywords":"","version":"0.2.x"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.2.x/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.2.x","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.2.x/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.2.x","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.2.x/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.2.1&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.2.x","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.2.x"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/intro","content":"","keywords":"","version":"0.2.x"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.2.x/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.2.x","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.2.x/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.2.x","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.2.x/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   ","version":"0.2.x","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.2.x/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.2.x","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.2.x/intro#license","content":" Touying is released under the MIT license. ","version":"0.2.x","tagName":"h2"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/dynamic/other","content":"","keywords":"","version":"0.2.x"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.2.x/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.2.1&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.1&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slide) = utils.methods(s) #show: init // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.2.x","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.2.x/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.2.x","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/progress/counters","content":"","keywords":"","version":"0.2.x"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.2.x/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.2.x","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.2.x/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.2.x","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.2.x/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.2.x","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.2.x/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.2.x","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/progress/sections","content":"","keywords":"","version":"0.2.x"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.2.x/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  ","version":"0.2.x","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.2.x/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.2.x","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.2.x/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.2.x","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/start","content":"","keywords":"","version":"0.2.x"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/0.2.x/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，例如上面的例子依靠一级和二级标题来划分新 slide，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.2.1&quot;: * #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide) = utils.methods(s) #show: init // simple animations #slide[ a simple #pause *dynamic* #pause slide. #meanwhile meanwhile #pause with pause. ][ second #pause pause. ] // complex animations #slide(setting: body =&gt; { set text(fill: blue) body }, repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) in subslide #self.subslide test #uncover(&quot;2-&quot;)[uncover] function test #only(&quot;2-&quot;)[only] function #pause and paused text. ]) // math equation animations #slide[ == Touying Equation #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ] // multiple pages for one slide #slide[ == Multiple Pages for One Slide #lorem(200) ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.methods(s) #slide[ == Appendix ]     除此之外，Touying 还提供了很多内置的主题，能够简单地编写精美的 slides，基本上，您只需要在文档顶部加入一行  #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;)   即可使用 metropolis 主题。关于更详细的教程，您可以参阅后面的章节。 ","version":"0.2.x","tagName":"h2"},{"title":"排篇布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/layout","content":"","keywords":"","version":"0.2.x"},{"title":"全局信息​","type":1,"pageTitle":"排篇布局","url":"/touying/zh/docs/0.2.x/layout#全局信息","content":" 你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slide, slides) = utils.methods(s)   ","version":"0.2.x","tagName":"h2"},{"title":"节与小节​","type":1,"pageTitle":"排篇布局","url":"/touying/zh/docs/0.2.x/layout#节与小节","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  在 #show: slides 模式下，section 和 subsection 分别对应着一级标题和二级标题，例如  #import &quot;@preview/touying:0.2.1&quot;: * #let (init, slide, slides) = utils.methods(s) #show: init #show: slides = Section == Subsection Hello, Touying!     不过二级标题并非总是对应 subsection，具体的映射方式因主题而异。  而在更通用的 #slide[..] 模式下，section 和 subsection 分别作为参数传入 slide 函数中，例如  #slide(section: [Let's start a new section!])[..] #slide(subsection: [Let's start a new subsection!])[..]   会分别新建一个 section 和一个 subsection。当然，这种变化默认只会影响到 Touying 内部的 sections state，默认是不会显示在 slide 上的，具体的显示方式依主题而异。  注意，slide 的 section 和 subsection 参数，既能接收内容块，也能接收形如 ([title], [short-title]) 格式的数组，或 (title: [title], short-title: [short-title]) 格式的字典。其中 short-title 会在一些特殊场景下用到，例如 dewdrop 主题的 navigation 中将会用到。  ","version":"0.2.x","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"排篇布局","url":"/touying/zh/docs/0.2.x/layout#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.2.1&quot;: * #let (init, slide, touying-outline) = utils.methods(s) #show: init #slide[ == Table of contents #touying-outline() ]   其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  如果你对目录有着复杂的自定义需求，你可以使用  #slide[ == Table of contents #states.touying-final-sections(sections =&gt; ..) ]   ","version":"0.2.x","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"排篇布局","url":"/touying/zh/docs/0.2.x/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择在单例 s 中维护一个 s.page-args 成员变量，只在创建新 slide 时才会应用这些参数。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  通过这种方式，我们可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。  ","version":"0.2.x","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"排篇布局","url":"/touying/zh/docs/0.2.x/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: utils.side-by-side.with(columns: (1fr, auto), gutter: 1em))[ First column. ][ Second column. ]    ","version":"0.2.x","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/style","content":"","keywords":"","version":"0.2.x"},{"title":"show-slides 风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.2.x/style#show-slides-风格","content":" 如果我们只是需要简单使用，我们可以通过 #show: slides 实现更简洁的语法。  但是这样做也有对应的弊端：第一个弊端是这种方式可能会极大地影响文档渲染性能，第二个弊端是后续不能直接加入 #slide(..)，而是需要手动标记 #slides-end，以及最大的弊端是实现不了复杂的功能。  #import &quot;@preview/touying:0.2.1&quot;: * #let (init, slide, slides) = utils.methods(s) #show: init #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst! #slides-end #slide[ A new slide. ]     并且你可以使用空标题 == 创建一个新页。  ","version":"0.2.x","tagName":"h2"},{"title":"slide-block 风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.2.x/style#slide-block-风格","content":" 为了更优秀的性能和更强大的能力，大部分情况我们还是需要使用  #slide[ A new slide. ]   这样的代码风格。 ","version":"0.2.x","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/themes/simple","content":"","keywords":"","version":"0.2.x"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.2.x/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, centered-slide, focus-slide) = utils.methods(s) #show: init   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.2.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.2.x/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.2.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.2.x/themes/simple#slides-函数","content":" #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, centered-slide, focus-slide) = utils.methods(s) #show: init #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.2.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.2.x/themes/simple#示例","content":" #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, centered-slide, focus-slide) = utils.methods(s) #show: init #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] #slide[ == First slide #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] #centered-slide(section: [Let's start a new section!]) #slide[ == Dynamic slide Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.2.x","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/themes/dewdrop","content":"","keywords":"","version":"0.2.x"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.dewdrop.register( s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.2.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.2.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.2.x","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.2.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。outline-title: 默认为 [Outline]。  可以通过 #show: slides.with(..) 的方式设置。  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.dewdrop.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.2.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.2.x/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.dewdrop.register( s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) // #let s = (s.methods.appendix-in-outline)(self: s, false) #let (init, slide, title-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #title-slide() #slide[ == Outline #touying-outline(cover: false) ] #slide(section: [Section A])[ == Outline #touying-outline() ] #slide(subsection: [Subsection A.1])[ == Title A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] #slide(subsection: [Subsection A.2])[ == Important A slide without a title but with *important* infos ] #slide(section: [Section B])[ == Outline #touying-outline() ] #slide(subsection: [Subsection B.1])[ == Another Subsection #lorem(80) ] #focus-slide[ Wake up! ] // simple animations #slide(subsection: [Subsection B.2])[ == Dynamic a simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.methods(s) #slide(section: [Appendix])[ == Outline #touying-outline() ] #slide[ appendix ]  ","version":"0.2.x","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/utilities/fit-to","content":"","keywords":"","version":"0.2.x"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.2.x/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.2.x","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.2.x/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.2.x","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let empty-object = (methods: (:)) 一个空类。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.2.x"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/themes/metropolis","content":"","keywords":"","version":"0.2.x"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.2.x/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.2.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.2.x/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.2.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.2.x/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, margin: (top: 3em, bottom: 1em, left: 0em, right: 0em), padding: 2em, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.2.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.2.x/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。outline-title: 默认为 [Table of contents]。  可以通过 #show: slides.with(..) 的方式设置。  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.2.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.2.x/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #title-slide(extra: [Extra]) #slide(title: [Table of contents])[ #touying-outline() ] #slide(title: [A long long long long long long long long long long long long long long long long long long long long long long long long Title])[ A slide with some maths: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] #new-section-slide[First section] #slide[ A slide without a title but with *important* infos ] #new-section-slide[Second section] #focus-slide[ Wake up! ] // simple animations #slide[ a simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, new-section-slide) = utils.methods(s) #new-section-slide[Appendix] #slide[ appendix ]  ","version":"0.2.x","tagName":"h2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.2.x/themes/university","content":"","keywords":"","version":"0.2.x"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.2.x/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slide, slides, title-slide, focus-slide, matrix-slide, touying-outline, alert) = utils.methods(s) #show: init   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。  并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.2.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.2.x/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), neutral-lightest: rgb(&quot;#FBFEF9&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.2.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.2.x/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, margin: (top: 2em, bottom: 1em, x: 0em), padding: (x: 2em, y: .5em), )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.2.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.2.x/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。  可以通过 #show: slides.with(..) 的方式设置。  #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slide, slides, title-slide, focus-slide, matrix-slide, touying-outline, alert) = utils.methods(s) #show: init #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.2.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.2.x/themes/university#示例","content":" #import &quot;@preview/touying:0.2.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slide, slides, title-slide, focus-slide, matrix-slide, touying-outline, alert) = utils.methods(s) #show: init #title-slide(authors: ([Author A], [Author B])) #slide(title: [Slide title], section: [The section])[ #lorem(40) ] #slide(title: [Slide title], subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ *Another variant with an image in background...* ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.2.x","tagName":"h2"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/changelog","content":"","keywords":"","version":"0.3.2+"},{"title":"v0.3.3​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v033","content":" template: move template to touying-aqua package, make Touying searchable in Typst Universe Packagesthemes: fix bugs in university and dewdrop themefeat: make set-show rule work without setting parameterfeat: make composer parameter more simplerfeat: add empty-slide function  ","version":"0.3.2+","tagName":"h2"},{"title":"v0.3.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v032","content":" fix critical bug: fix is-sequence function, make grid and table work correctly in touyingtheme: add aqua theme, thanks for pride7theme: make university theme more configurablerefactor: don't export variable s by default anymore, it will be extracted by register function (Breaking Change)meta: add categories and template config to typst.toml for Typst 0.11  ","version":"0.3.2+","tagName":"h2"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"0.3.2+","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v030","content":" ","version":"0.3.2+","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#features","content":" better show-slides mode.support align and pad.  ","version":"0.3.2+","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#documentation","content":" Add more detailed documentation.  ","version":"0.3.2+","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#refactor","content":" simplify theme.  ","version":"0.3.2+","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#fix","content":" fix many bugs.  ","version":"0.3.2+","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v021","content":" ","version":"0.3.2+","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#features-1","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.3.2+","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.3.2+","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.2+/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.3.2+","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/cover","content":"","keywords":"","version":"0.3.2+"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.2+/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.3.2+","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.2+/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.3.2+","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.2+/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.3.2+","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/complex","content":"","keywords":"","version":"0.3.2+"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.2+/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的 styled 与 layout 限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) In subslide #self.subslide, test #uncover(&quot;2-&quot;)[uncover] function, and test #only(&quot;2-&quot;)[only] function, #pause and paused text. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.3.2+","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.2+/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.3.2+","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.2+/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.3.2+","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.2+/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.3.2+","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/build-your-own-theme","content":"","keywords":"","version":"0.3.2+"},{"title":"修改已有主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#修改已有主题","content":" 如果你想在本地修改一个 Touying 内部的 themes，而不是自己从零开始创建，你可以选择通过下面的方式实现：  将 themes 目录下的 主题代码 复制到本地，例如将 themes/university.typ 复制到本地 university.typ 中。将 university.typ 文件顶部的 #import &quot;../xxx.typ&quot; 命令全部移除。向 university.typ 文件顶部中加入 #import &quot;@preview/touying:0.3.3&quot;: * 来导入所有模块。将 register 函数中的 self: s 替换成 self: themes.default.register() (重要)。  然后就可以通过  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;university.typ&quot; #let s = university.register(aspect-ratio: &quot;16-9&quot;)   的方式导入和使用主题了。  一个具体的示例：https://typst.app/project/rqRuzg0keo_ZEB5AdxjweA  ","version":"0.3.2+","tagName":"h2"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.3.3&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"0.3.2+","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.3.3&quot;: * #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。我们使用 self: themes.default.register() 的方式，获得了缺省的 self。然后我们就需要设置页面参数了。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"0.3.2+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register() 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"0.3.2+","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"0.3.2+","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们还设置了上下 margin 和左右 padding，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 0em)) 和 self.padding = (x: 2em, y: 0em)。左右 margin 为 0em 是为了让 header 能占满页面宽度，正文的左右间距就依靠左右 padding 2em 来实现。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.3.3&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 0em), ) self.padding = (x: 2em, y: 0em) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"0.3.2+","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 和 padding 都设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.3.3&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 0em), ) self.padding = (x: 2em, y: 0em) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"0.3.2+","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.2+/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"0.3.2+","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/code-styles","content":"","keywords":"","version":"0.3.2+"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.2+/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"0.3.2+","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.2+/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide, empty-slide) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   以及 #empty-slide[] 可以创建一个没有 header 和 footer 的空 Slide。  这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"0.3.2+","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.2+/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"0.3.2+","tagName":"h2"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/equation","content":"","keywords":"","version":"0.3.2+"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.2+/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.3.2+","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.2+/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.3.2+","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.2+/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.3.2+","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.3.2+"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.3.2+"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/other","content":"","keywords":"","version":"0.3.2+"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.3.2+/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.3.2+","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.3.2+/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.3.2+","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/external/pdfpc","content":"","keywords":"","version":"0.3.2+"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.2+/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.3.2+","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.2+/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.3.2+","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.2+/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.3.3&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.3.2+","tagName":"h2"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/dynamic/simple","content":"","keywords":"","version":"0.3.2+"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.2+/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.3.2+","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.2+/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.3.2+","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.2+/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了像 grid 这类 layout 函数，你会惊讶地发现其内部的 #pause 和 #meanwhile 失效了。但是你可以使用 #slide() 的 composer 参数来布局，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.3.2+","tagName":"h2"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/cetz","content":"","keywords":"","version":"0.3.2+"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.3.2+/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.3.2+","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.3.2+/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.3.2+","tagName":"h2"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"0.3.2+"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"0.3.2+"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/global-settings","content":"","keywords":"","version":"0.3.2+"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.2+/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"0.3.2+","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.2+/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"0.3.2+","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.2+/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"0.3.2+","tagName":"h2"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) ","keywords":"","version":"0.3.2+"},{"title":"Polylux","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/polylux","content":"Polylux 借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要在你的 Polylux 源代码中加入下面的代码即可。 #import &quot;@preview/touying:0.3.3&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc)) 假设你的文档为 ./example.typ，则你可以通过 typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc 直接导出 .pdfpc 文件，而不需要使用额外的 polylux2pdfpc 程序。","keywords":"","version":"0.3.2+"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/integration/pinit","content":"","keywords":"","version":"0.3.2+"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.3.2+/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"0.3.2+","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.3.2+/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide, empty-slide) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"0.3.2+","tagName":"h2"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/intro","content":"","keywords":"","version":"0.3.2+"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.2+/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.3.2+","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.2+/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.3.2+","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.2+/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"0.3.2+","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.2+/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.3.2+","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.2+/intro#license","content":" Touying is released under the MIT license. ","version":"0.3.2+","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/progress/counters","content":"","keywords":"","version":"0.3.2+"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.2+/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.3.2+","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.2+/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.3.2+","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.2+/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.3.2+","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.2+/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.3.2+","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/layout","content":"","keywords":"","version":"0.3.2+"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.2+/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #let padding = (x: 2em, y: 2em) #place(top + right)[Margin→] #container[ #place[Padding] #pad(..padding)[ #container[ #innerbox[Content] ] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer，其实际上是位于 Margin 内部。Padding: 用于在 Margin 和 Content 之间添加额外的间隙。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，又分为 container 和 innerbox。我们可以注意到 footer container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 footer-descent: 30%，而这里的百分比是相对于 margin-bottom 而言的。并且，我们注意到 footer innerbox 实际上位于 footer container 左上角，也即 innerbox 实际上默认有属性 #set align(left + top)。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ) #let padding = (x: 4em, y: 0em)   即可。例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: (x: 0em, y: 2em), header: container[#align(top)[#innerbox(width: 100%)[Header]]], header-ascent: 0em, footer: container[#align(bottom)[#innerbox(width: 100%)[Footer]]], footer-descent: 0em, ) #let padding = (x: 4em, y: 0em) #place(top + right)[↑Margin] #container[ #place[Padding] #pad(..padding)[ #container[ #innerbox[Content] ] ] ]     ","version":"0.3.2+","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.2+/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide, empty-slide) = utils.slides(s) 之前，否则就需要重新调用 #let (slide, empty-slide) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"0.3.2+","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.2+/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"0.3.2+","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.2+/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: (1fr, auto))[ First column. ][ Second column. ]    ","version":"0.3.2+","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/progress/sections","content":"","keywords":"","version":"0.3.2+"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.2+/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  ","version":"0.3.2+","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.2+/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.3.2+","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.2+/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.3.2+","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/sections","content":"","keywords":"","version":"0.3.2+"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.3.2+/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.dewdrop.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.university.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"0.3.2+","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.3.2+/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register() #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"0.3.2+","tagName":"h2"},{"title":"Aqua 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/themes/aqua","content":"","keywords":"","version":"0.3.2+"},{"title":"初始化​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.3.2+/themes/aqua#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚右侧的内容，默认为 states.slide-counter.display()。lang: 语言配置，目前只支持 &quot;en&quot; 和 &quot;zh&quot;，默认为 &quot;en&quot;,  并且 Aqua 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.2+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.3.2+/themes/aqua#颜色主题","content":" Aqua 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#003F88&quot;), primary-light: rgb(&quot;#2159A5&quot;), primary-lightest: rgb(&quot;#F2F4F8&quot;),   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.2+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.3.2+/themes/aqua#slide-函数族","content":" Aqua 主题提供了一系列自定义 slide 函数：  #title-slide(..args)   title-slide 会读取 self.info 里的信息用于显示。    #let outline-slide(self: none, enum-args: (:), leading: 50pt)   显示一个大纲页。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Aqua theme title: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。    #new-section-slide(title)   用给定标题开启一个新的 section。  ","version":"0.3.2+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.3.2+/themes/aqua#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.2+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.3.2+/themes/aqua#示例","content":" #import &quot;../lib.typ&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = The Section == Slide Title #slide[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] == Summary #align(center + horizon)[ #set text(size: 3em, weight: &quot;bold&quot;, s.colors.primary) THANKS FOR ALL ]  ","version":"0.3.2+","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/start","content":"","keywords":"","version":"0.3.2+"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/0.3.2+/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Extract methods #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] == Complex Animation #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation #slide[ Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. ] == CeTZ Animation #slide[ CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] == Fletcher Animation #slide[ Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] = Others == Side-by-side #slide[ First column. ][ Second column. ] == Multiple Pages #slide[ #lorem(200) ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"0.3.2+","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/themes/dewdrop","content":"","keywords":"","version":"0.3.2+"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.2+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.2+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.3.2+","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.3.2+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.dewdrop.register(aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.2+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.2+/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"0.3.2+","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/themes/simple","content":"","keywords":"","version":"0.3.2+"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.2+/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.3.2+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.2+/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.3.2+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.2+/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.2+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.2+/themes/simple#示例","content":" #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.3.2+","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/utilities/fit-to","content":"","keywords":"","version":"0.3.2+"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.3.2+/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.3.2+","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.3.2+/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.3.2+","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.3.2+"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/themes/metropolis","content":"","keywords":"","version":"0.3.2+"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.2+/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.2+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.2+/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.2+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.2+/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.3.2+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.2+/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.2+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.2+/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"0.3.2+","tagName":"h2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.2+/themes/university","content":"","keywords":"","version":"0.3.2+"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.2+/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。display-current-section: 是否显示当前节标题。footer-columns: 底部三栏 Footer 的宽度，默认为 (25%, 1fr, 25%)。footer-a: 第一栏，默认为 self =&gt; self.info.author。footer-b: 第二栏，默认为 self =&gt; if self.info.short-title == auto { self.info.title } else { self.info.short-title }。footer-c: 第三栏，默认为  self =&gt; { h(1fr) utils.info-date(self) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number h(1fr) }   并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.2+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.2+/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.2+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.2+/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.3.2+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.2+/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.2+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.2+/themes/university#示例","content":" #import &quot;@preview/touying:0.3.3&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ *Another variant with primary color in background...* ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.3.2+","tagName":"h2"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/changelog","content":"","keywords":"","version":"0.3.x"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"0.3.x","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#v030","content":" ","version":"0.3.x","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#features","content":" better show-slides mode.support align and pad.  ","version":"0.3.x","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#documentation","content":" Add more detailed documentation.  ","version":"0.3.x","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#refactor","content":" simplify theme.  ","version":"0.3.x","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#fix","content":" fix many bugs.  ","version":"0.3.x","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#v021","content":" ","version":"0.3.x","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#features-1","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.3.x","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.3.x","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.3.x/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.3.x","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/complex","content":"","keywords":"","version":"0.3.x"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.x/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的 styled 与 layout 限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) In subslide #self.subslide, test #uncover(&quot;2-&quot;)[uncover] function, and test #only(&quot;2-&quot;)[only] function, #pause and paused text. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.3.x","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.x/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.3.x","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.x/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.3.x","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.3.x/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.3.x","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/code-styles","content":"","keywords":"","version":"0.3.x"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.x/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"0.3.x","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.x/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide,) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"0.3.x","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.3.x/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s) #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s) #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s) #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"0.3.x","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/cover","content":"","keywords":"","version":"0.3.x"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.x/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.3.x","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.x/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.3.x","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.3.x/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.3.x","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/build-your-own-theme","content":"","keywords":"","version":"0.3.x"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.3.1&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"0.3.x","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.3.1&quot;: * #let register( aspect-ratio: &quot;16-9&quot;, self, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(s, aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide,) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"0.3.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( aspect-ratio: &quot;16-9&quot;, self, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register(s) 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"0.3.x","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"0.3.x","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们还设置了上下 margin 和左右 padding，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 0em)) 和 self.padding = (x: 2em, y: 0em)。左右 margin 为 0em 是为了让 header 能占满页面宽度，正文的左右间距就依靠左右 padding 2em 来实现。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.3.1&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( aspect-ratio: &quot;16-9&quot;, footer: [], self, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 0em), ) self.padding = (x: 2em, y: 0em) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide,) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"0.3.x","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 和 padding 都设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.3.1&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( aspect-ratio: &quot;16-9&quot;, footer: [], self, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 0em), ) self.padding = (x: 2em, y: 0em) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"0.3.x","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.3.x/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"0.3.x","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.3.x"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/equation","content":"","keywords":"","version":"0.3.x"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.x/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.3.x","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.x/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.3.x","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.3.x/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.3.x","tagName":"h2"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/other","content":"","keywords":"","version":"0.3.x"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.3.x/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.3.x","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.3.x/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.3.x","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.3.x"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/dynamic/simple","content":"","keywords":"","version":"0.3.x"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.x/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.3.x","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.x/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.3.x","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.3.x/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了 set-show rules，你会惊讶的发现，在那之后的 #pause 和 #meanwhile 都失效了。这是因为 Touying 无法探知 styled(..) 内部的内容（set-show rules 后的内容会被 styled 囊括起来）。  为了解决这个问题，Touying 为 #slide() 函数提供了一个 setting 参数，你可以将你的 set-show rules 放到 setting 参数里，例如修改字体颜色：  #slide(setting: body =&gt; { set text(fill: blue) body })[ First #pause Second ]     同理，Touying 目前也不支持 grid 这类 layout 函数内部的 #pause 和 #meanwhile，也是由于同样的限制，但是你可以使用 #slide() 的 composer 参数，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.3.x","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/external/pdfpc","content":"","keywords":"","version":"0.3.x"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.x/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.3.x","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.x/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.3.x","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.3.x/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.3.1&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.3.x","tagName":"h2"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/cetz","content":"","keywords":"","version":"0.3.x"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.3.x/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.3.x","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.3.x/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.3.x","tagName":"h2"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide,) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"0.3.x"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/global-settings","content":"","keywords":"","version":"0.3.x"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.x/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"0.3.x","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.x/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"0.3.x","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.3.x/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide,) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"0.3.x","tagName":"h2"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) ","keywords":"","version":"0.3.x"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"0.3.x"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/pinit","content":"","keywords":"","version":"0.3.x"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.3.x/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"0.3.x","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.3.x/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide,) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"0.3.x","tagName":"h2"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/intro","content":"","keywords":"","version":"0.3.x"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.x/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.3.x","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.x/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.3.x","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.x/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"0.3.x","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.x/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.3.x","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.3.x/intro#license","content":" Touying is released under the MIT license. ","version":"0.3.x","tagName":"h2"},{"title":"Polylux","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/integration/polylux","content":"Polylux 借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要在你的 Polylux 源代码中加入下面的代码即可。 #import &quot;@preview/touying:0.3.1&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc)) 假设你的文档为 ./example.typ，则你可以通过 typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc 直接导出 .pdfpc 文件，而不需要使用额外的 polylux2pdfpc 程序。","keywords":"","version":"0.3.x"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/progress/counters","content":"","keywords":"","version":"0.3.x"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.x/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.3.x","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.x/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.3.x","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.x/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.3.x","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.3.x/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.3.x","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/progress/sections","content":"","keywords":"","version":"0.3.x"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.x/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  ","version":"0.3.x","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.x/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.3.x","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.3.x/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.3.x","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/layout","content":"","keywords":"","version":"0.3.x"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.x/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #let padding = (x: 2em, y: 2em) #place(top + right)[Margin→] #container[ #place[Padding] #pad(..padding)[ #container[ #innerbox[Content] ] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer，其实际上是位于 Margin 内部。Padding: 用于在 Margin 和 Content 之间添加额外的间隙。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，又分为 container 和 innerbox。我们可以注意到 footer container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 footer-descent: 30%，而这里的百分比是相对于 margin-bottom 而言的。并且，我们注意到 footer innerbox 实际上位于 footer container 左上角，也即 innerbox 实际上默认有属性 #set align(left + top)。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ) #let padding = (x: 4em, y: 0em)   即可。例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: (x: 0em, y: 2em), header: container[#align(top)[#innerbox(width: 100%)[Header]]], header-ascent: 0em, footer: container[#align(bottom)[#innerbox(width: 100%)[Footer]]], footer-descent: 0em, ) #let padding = (x: 4em, y: 0em) #place(top + right)[↑Margin] #container[ #place[Padding] #pad(..padding)[ #container[ #innerbox[Content] ] ] ]     ","version":"0.3.x","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.x/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide,) = utils.slides(s) 之前，否则就需要重新调用 #let (slide,) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"0.3.x","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.x/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"0.3.x","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.3.x/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: utils.side-by-side.with(columns: (1fr, auto), gutter: 1em))[ First column. ][ Second column. ]    ","version":"0.3.x","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/sections","content":"","keywords":"","version":"0.3.x"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.3.x/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.dewdrop.register(s) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.university.register(s) #let (init, slides) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"0.3.x","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.3.x/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.3.1&quot;: * #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide,) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"0.3.x","tagName":"h2"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/themes/metropolis","content":"","keywords":"","version":"0.3.x"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.x/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.x/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.x/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.3.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.x/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.3.x/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.metropolis.register(s, aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"0.3.x","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/themes/simple","content":"","keywords":"","version":"0.3.x"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.x/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.3.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.x/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.3.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.x/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.3.x/themes/simple#示例","content":" #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.simple.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.3.x","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/themes/dewdrop","content":"","keywords":"","version":"0.3.x"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.dewdrop.register( s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.3.x","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.3.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.dewdrop.register(s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.3.x/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.dewdrop.register( s, aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"0.3.x","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/start","content":"","keywords":"","version":"0.3.x"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/0.3.x/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.3.1&quot;: * #import &quot;@preview/cetz:0.2.1&quot; #import &quot;@preview/fletcher:0.4.2&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: (arr, ..args) =&gt; fletcher.diagram(..args, ..arr)) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Extract methods #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide,) = utils.slides(s) #show: slides = Animation == Simple Animation #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] == Complex Animation #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation #slide[ Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. ] == CeTZ Animation #slide[ CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] == Fletcher Animation #slide[ Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] = Others == Side-by-side #slide[ First column. ][ Second column. ] == Setting #slide(setting: body =&gt; { set text(fill: blue) body })[ This slide has blue text. ] == Multiple Pages #slide[ #lorem(200) ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide,) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"0.3.x","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.3.x"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/utilities/fit-to","content":"","keywords":"","version":"0.3.x"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.3.x/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.3.x","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.3.x/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.3.x","tagName":"h2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.3.x/themes/university","content":"","keywords":"","version":"0.3.x"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.x/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。  并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.3.x","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.x/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.3.x","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.x/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.3.x","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.x/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.3.x","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.3.x/themes/university#示例","content":" #import &quot;@preview/touying:0.3.1&quot;: * #let s = themes.university.register(s, aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #let (slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ *Another variant with primary color in background...* ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.3.x","tagName":"h2"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/changelog","content":"","keywords":"","version":"0.4.0+"},{"title":"v0.4.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v040","content":" ","version":"0.4.0+","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#features","content":" feat: support #footnote[] for all themes.feat: access subslide and repeat in footer and header by self =&gt; self.subslide.feat: support numbered theorem environments by ctheorems.feat: support numbering for sections and subsections.  ","version":"0.4.0+","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#fixes","content":" fix: make nested includes work correctly.fix: disable multi-page slides from creating the same section multiple times.  ","version":"0.4.0+","tagName":"h3"},{"title":"Breaking changes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#breaking-changes","content":" refactor: remove self.padding and add self.full-header self.full-footer config.  ","version":"0.4.0+","tagName":"h2"},{"title":"v0.3.3​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v033","content":" template: move template to touying-aqua package, make Touying searchable in Typst Universe Packagesthemes: fix bugs in university and dewdrop themefeat: make set-show rule work without setting parameterfeat: make composer parameter more simplerfeat: add empty-slide function  ","version":"0.4.0+","tagName":"h2"},{"title":"v0.3.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v032","content":" fix critical bug: fix is-sequence function, make grid and table work correctly in touyingtheme: add aqua theme, thanks for pride7theme: make university theme more configurablerefactor: don't export variable s by default anymore, it will be extracted by register function (Breaking Change)meta: add categories and template config to typst.toml for Typst 0.11  ","version":"0.4.0+","tagName":"h2"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"0.4.0+","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v030","content":" ","version":"0.4.0+","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#features-1","content":" better show-slides mode.support align and pad.  ","version":"0.4.0+","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#documentation","content":" Add more detailed documentation.  ","version":"0.4.0+","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#refactor","content":" simplify theme.  ","version":"0.4.0+","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#fix","content":" fix many bugs.  ","version":"0.4.0+","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v021","content":" ","version":"0.4.0+","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#features-2","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.4.0+","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.4.0+","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.0+/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.4.0+","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/complex","content":"","keywords":"","version":"0.4.0+"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.0+/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的 styled 与 layout 限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) In subslide #self.subslide, test #uncover(&quot;2-&quot;)[uncover] function, and test #only(&quot;2-&quot;)[only] function, #pause and paused text. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.4.0+","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.0+/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.4.0+","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.0+/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.4.0+","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.0+/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.4.0+","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/code-styles","content":"","keywords":"","version":"0.4.0+"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.0+/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"0.4.0+","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.0+/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide, empty-slide) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   以及 #empty-slide[] 可以创建一个没有 header 和 footer 的空 Slide。  这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"0.4.0+","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.0+/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"0.4.0+","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/cover","content":"","keywords":"","version":"0.4.0+"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.0+/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.4.0+","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.0+/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.4.0+","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.0+/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.4.0+","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.4.0+"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/equation","content":"","keywords":"","version":"0.4.0+"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.0+/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.4.0+","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.0+/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.4.0+","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.0+/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.4.0+","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/build-your-own-theme","content":"","keywords":"","version":"0.4.0+"},{"title":"修改已有主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#修改已有主题","content":" 如果你想在本地修改一个 Touying 内部的 themes，而不是自己从零开始创建，你可以选择通过下面的方式实现：  将 themes 目录下的 主题代码 复制到本地，例如将 themes/university.typ 复制到本地 university.typ 中。将 university.typ 文件顶部的 #import &quot;../xxx.typ&quot; 命令全部移除。向 university.typ 文件顶部中加入 #import &quot;@preview/touying:0.4.0&quot;: * 来导入所有模块。将 register 函数中的 self: s 替换成 self: themes.default.register() (重要)。  然后就可以通过  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;university.typ&quot; #let s = university.register(aspect-ratio: &quot;16-9&quot;)   的方式导入和使用主题了。  一个具体的示例：https://typst.app/project/rqRuzg0keo_ZEB5AdxjweA  ","version":"0.4.0+","tagName":"h2"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.4.0&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"0.4.0+","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.4.0&quot;: * #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。我们使用 self: themes.default.register() 的方式，获得了缺省的 self。然后我们就需要设置页面参数了。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"0.4.0+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register() 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"0.4.0+","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"0.4.0+","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们需要设置 margin，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 2em))。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.4.0&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"0.4.0+","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.4.0&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"0.4.0+","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.0+/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"0.4.0+","tagName":"h2"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/simple","content":"","keywords":"","version":"0.4.0+"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.0+/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.4.0+","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.0+/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.4.0+","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.0+/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了像 grid 这类 layout 函数，你会惊讶地发现其内部的 #pause 和 #meanwhile 失效了。但是你可以使用 #slide() 的 composer 参数来布局，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.4.0+","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/external/pdfpc","content":"","keywords":"","version":"0.4.0+"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.0+/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.4.0+","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.0+/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.4.0+","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.0+/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.4.0&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.4.0+","tagName":"h2"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/dynamic/other","content":"","keywords":"","version":"0.4.0+"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.4.0+/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.0+","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.4.0+/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.0+","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.4.0+"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"0.4.0+"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/cetz","content":"","keywords":"","version":"0.4.0+"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.4.0+/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.0+","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.4.0+/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.0+","tagName":"h2"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/global-settings","content":"","keywords":"","version":"0.4.0+"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.0+/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"0.4.0+","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.0+/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"0.4.0+","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.0+/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"0.4.0+","tagName":"h2"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"0.4.0+"},{"title":"Ctheorems","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/ctheorems","content":"Ctheorems Touying 能够与 ctheorems 包一起正常工作，你可以直接使用 ctheorems 包。 其中，你还可以使用 #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) 为 sections 和 subsections 设置 numbering。 #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/ctheorems:1.1.2&quot;: * // Register university theme #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] ","keywords":"","version":"0.4.0+"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) ","keywords":"","version":"0.4.0+"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/intro","content":"","keywords":"","version":"0.4.0+"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.0+/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.4.0+","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.0+/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.4.0+","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.0+/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"0.4.0+","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.0+/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.4.0+","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.0+/intro#license","content":" Touying is released under the MIT license. ","version":"0.4.0+","tagName":"h2"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/integration/pinit","content":"","keywords":"","version":"0.4.0+"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.4.0+/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"0.4.0+","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.4.0+/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide, empty-slide) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"0.4.0+","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/progress/counters","content":"","keywords":"","version":"0.4.0+"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.0+/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.4.0+","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.0+/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.4.0+","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.0+/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.4.0+","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.0+/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.4.0+","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/layout","content":"","keywords":"","version":"0.4.0+"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.0+/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #place(top + right)[Margin→] #container[ #container[ #innerbox[Content] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer。Header 和 Footer 实际上是位于 Margin 内部。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，与 Header 类似，只不过方向相反。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )   即可。但是我们还需要解决 header 如何占据整个页面宽度的问题，在这里我们使用 negative padding 实现，例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #let margin = (x: 4em, y: 2em) // negative padding for header and footer #let negative-padding = pad.with(x: -margin.x, y: 0em) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: margin, header: negative-padding[#container[#align(top)[#innerbox(width: 100%)[Header]]]], header-ascent: 0em, footer: negative-padding[#container[#align(bottom)[#innerbox(width: 100%)[Footer]]]], footer-descent: 0em, ) #place(top + right)[↑Margin→] #container[ #container[ #innerbox[Content] ] ]     ","version":"0.4.0+","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.0+/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ))   Touying 会自动检测 margin.x 的值，并且判断如果 self.full-header == true，就会自动为 header 加入负填充。  同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide, empty-slide) = utils.slides(s) 之前，否则就需要重新调用 #let (slide, empty-slide) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"0.4.0+","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.0+/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"0.4.0+","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.0+/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: (1fr, auto))[ First column. ][ Second column. ]    ","version":"0.4.0+","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/progress/sections","content":"","keywords":"","version":"0.4.0+"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.0+/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  ","version":"0.4.0+","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.0+/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.4.0+","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.0+/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.4.0+","tagName":"h2"},{"title":"多文件架构","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/multi-file","content":"","keywords":"","version":"0.4.0+"},{"title":"配置和内容分离​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/0.4.0+/multi-file#配置和内容分离","content":" 一个最简单的 Touying 多文件架构包括三个文件：全局配置文件 globals.typ、主入口文件 main.typ 和存放内容的 content.typ 文件。  分成三个文件是由于要让 main.typ 和 content.typ 均可以引入 globals.typ，从而避免循环引用。  globals.typ 可以用于存放一些全局的自定义函数，以及对 Touying 主题进行初始化：  // globals.typ #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) // as well as some utility functions   main.typ 作为项目的主入口，通过导入 globals.typ 应用 show rules，以及通过 #include 置入 content.typ。  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;content.typ&quot;   content.typ 便是用于书写具体内容的文件了。  // content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   ","version":"0.4.0+","tagName":"h2"},{"title":"多章节​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/0.4.0+/multi-file#多章节","content":" 要实现多章节也十分简单，只需要新建一个 sections 目录，并将上面的 content.typ 文件移动至 sections.typ 目录即可，例如  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;sections/content.typ&quot; // #include &quot;sections/another-section.typ&quot;   和  // sections/content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   这样，您就掌握了如何使用 Touying 实现大型 slides 的多文件架构。 ","version":"0.4.0+","tagName":"h2"},{"title":"Aqua 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/themes/aqua","content":"","keywords":"","version":"0.4.0+"},{"title":"初始化​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.0+/themes/aqua#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚右侧的内容，默认为 states.slide-counter.display()。lang: 语言配置，目前只支持 &quot;en&quot; 和 &quot;zh&quot;，默认为 &quot;en&quot;,  并且 Aqua 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.0+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.0+/themes/aqua#颜色主题","content":" Aqua 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#003F88&quot;), primary-light: rgb(&quot;#2159A5&quot;), primary-lightest: rgb(&quot;#F2F4F8&quot;),   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.0+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.0+/themes/aqua#slide-函数族","content":" Aqua 主题提供了一系列自定义 slide 函数：  #title-slide(..args)   title-slide 会读取 self.info 里的信息用于显示。    #let outline-slide(self: none, enum-args: (:), leading: 50pt)   显示一个大纲页。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Aqua theme title: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。    #new-section-slide(title)   用给定标题开启一个新的 section。  ","version":"0.4.0+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.0+/themes/aqua#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.0+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.0+/themes/aqua#示例","content":" #import &quot;../lib.typ&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = The Section == Slide Title #slide[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] == Summary #align(center + horizon)[ #set text(size: 3em, weight: &quot;bold&quot;, s.colors.primary) THANKS FOR ALL ]  ","version":"0.4.0+","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/sections","content":"","keywords":"","version":"0.4.0+"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.0+/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.dewdrop.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.university.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"0.4.0+","tagName":"h2"},{"title":"编号​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.0+/sections#编号","content":" 为了给节与小节加入编号，我们只需要使用  #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;)   即可设置默认编号为 1.1，且 section 对应的编号为 1.。  ","version":"0.4.0+","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.0+/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register() #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"0.4.0+","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/start","content":"","keywords":"","version":"0.4.0+"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/0.4.0+/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge #import &quot;@preview/ctheorems:1.1.2&quot;: * // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. == Complex Animation #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. == CeTZ Animation CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) == Fletcher Animation Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] = Others == Side-by-side #slide(composer: (1fr, 1fr))[ First column. ][ Second column. ] == Multiple Pages #lorem(200) // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"0.4.0+","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/themes/dewdrop","content":"","keywords":"","version":"0.4.0+"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.0+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.0+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.4.0+","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.4.0+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.dewdrop.register(aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.0+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.0+/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"0.4.0+","tagName":"h2"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/themes/metropolis","content":"","keywords":"","version":"0.4.0+"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.0+/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.0+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.0+/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.0+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.0+/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.4.0+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.0+/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.0+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.0+/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"0.4.0+","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/utilities/fit-to","content":"","keywords":"","version":"0.4.0+"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.4.0+/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.4.0+","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.4.0+/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.4.0+","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/themes/simple","content":"","keywords":"","version":"0.4.0+"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.0+/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.4.0+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.0+/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.4.0+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.0+/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.0+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.0+/themes/simple#示例","content":" #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.4.0+","tagName":"h2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/themes/university","content":"","keywords":"","version":"0.4.0+"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.0+/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。display-current-section: 是否显示当前节标题。footer-columns: 底部三栏 Footer 的宽度，默认为 (25%, 1fr, 25%)。footer-a: 第一栏，默认为 self =&gt; self.info.author。footer-b: 第二栏，默认为 self =&gt; if self.info.short-title == auto { self.info.title } else { self.info.short-title }。footer-c: 第三栏，默认为  self =&gt; { h(1fr) utils.info-date(self) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number h(1fr) }   并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.0+","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.0+/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.0+","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.0+/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.4.0+","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.0+/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.0+","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.0+/themes/university#示例","content":" #import &quot;@preview/touying:0.4.0&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.4.0+","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.0+/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.4.0+"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/changelog","content":"","keywords":"","version":"0.4.1"},{"title":"v0.4.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v041","content":" ","version":"0.4.1","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#features","content":" feat: support builtin outline and bookmarkfeat: support speaker note for dual-screenfeat: add touying-mitex functionfeat: touying offers a gallery page via wiki  ","version":"0.4.1","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#fixes","content":" fix: add outline-slide for dewdrop themefix: fix regression of default value &quot;auto&quot; for repeat  ","version":"0.4.1","tagName":"h3"},{"title":"Miscellaneous Improvements​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#miscellaneous-improvements","content":" feat: add list support for touying-outline functionfeat: add auto-reset-footnotefeat: add freeze-in-empty-page for better page counterfeat: add ..args for register method to capture unused arguments  ","version":"0.4.1","tagName":"h3"},{"title":"v0.4.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v040","content":" ","version":"0.4.1","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#features-1","content":" feat: support #footnote[] for all themes.feat: access subslide and repeat in footer and header by self =&gt; self.subslide.feat: support numbered theorem environments by ctheorems.feat: support numbering for sections and subsections.  ","version":"0.4.1","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#fixes-1","content":" fix: make nested includes work correctly.fix: disable multi-page slides from creating the same section multiple times.  ","version":"0.4.1","tagName":"h3"},{"title":"Breaking changes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#breaking-changes","content":" refactor: remove self.padding and add self.full-header self.full-footer config.  ","version":"0.4.1","tagName":"h2"},{"title":"v0.3.3​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v033","content":" template: move template to touying-aqua package, make Touying searchable in Typst Universe Packagesthemes: fix bugs in university and dewdrop themefeat: make set-show rule work without setting parameterfeat: make composer parameter more simplerfeat: add empty-slide function  ","version":"0.4.1","tagName":"h2"},{"title":"v0.3.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v032","content":" fix critical bug: fix is-sequence function, make grid and table work correctly in touyingtheme: add aqua theme, thanks for pride7theme: make university theme more configurablerefactor: don't export variable s by default anymore, it will be extracted by register function (Breaking Change)meta: add categories and template config to typst.toml for Typst 0.11  ","version":"0.4.1","tagName":"h2"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"0.4.1","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v030","content":" ","version":"0.4.1","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#features-2","content":" better show-slides mode.support align and pad.  ","version":"0.4.1","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#documentation","content":" Add more detailed documentation.  ","version":"0.4.1","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#refactor","content":" simplify theme.  ","version":"0.4.1","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#fix","content":" fix many bugs.  ","version":"0.4.1","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v021","content":" ","version":"0.4.1","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#features-3","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.4.1","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.4.1","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/0.4.1/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.4.1","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/code-styles","content":"","keywords":"","version":"0.4.1"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.1/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"0.4.1","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.1/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide, empty-slide) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   以及 #empty-slide[] 可以创建一个没有 header 和 footer 的空 Slide。  这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"0.4.1","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/0.4.1/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"0.4.1","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/build-your-own-theme","content":"","keywords":"","version":"0.4.1"},{"title":"修改已有主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#修改已有主题","content":" 如果你想在本地修改一个 Touying 内部的 themes，而不是自己从零开始创建，你可以选择通过下面的方式实现：  将 themes 目录下的 主题代码 复制到本地，例如将 themes/university.typ 复制到本地 university.typ 中。将 university.typ 文件顶部的 #import &quot;../xxx.typ&quot; 命令全部移除。向 university.typ 文件顶部中加入 #import &quot;@preview/touying:0.4.1&quot;: * 来导入所有模块。将 register 函数中的 self: s 替换成 self: themes.default.register() (重要)。  然后就可以通过  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;university.typ&quot; #let s = university.register(aspect-ratio: &quot;16-9&quot;)   的方式导入和使用主题了。  一个具体的示例：https://typst.app/project/rqRuzg0keo_ZEB5AdxjweA  ","version":"0.4.1","tagName":"h2"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.4.1&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"0.4.1","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.4.1&quot;: * #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。我们使用 self: themes.default.register() 的方式，获得了缺省的 self。然后我们就需要设置页面参数了。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"0.4.1","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register() 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"0.4.1","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"0.4.1","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们需要设置 margin，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 2em))。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.4.1&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"0.4.1","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.4.1&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"0.4.1","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/0.4.1/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"0.4.1","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/complex","content":"","keywords":"","version":"0.4.1"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.1/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的 styled 与 layout 限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) In subslide #self.subslide, test #uncover(&quot;2-&quot;)[uncover] function, and test #only(&quot;2-&quot;)[only] function, #pause and paused text. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.4.1","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.1/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.4.1","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.1/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.4.1","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/0.4.1/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.4.1","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/cover","content":"","keywords":"","version":"0.4.1"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.1/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.4.1","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.1/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.4.1","tagName":"h2"},{"title":"hack: 处理 enum 和 list​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.1/dynamic/cover#hack-处理-enum-和-list","content":" 你会发现现有的 cover 函数无法隐藏 enum 和 list 的 mark，参考 这里，因此你可以进行 hack：  #let s = (s.methods.update-cover)(self: s, body =&gt; box(scale(x: 0%, body)))   ","version":"0.4.1","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/0.4.1/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.4.1","tagName":"h2"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/equation","content":"","keywords":"","version":"0.4.1"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.1/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.4.1","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.1/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.4.1","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/0.4.1/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.4.1","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.4.1"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/other","content":"","keywords":"","version":"0.4.1"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.4.1/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.1","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/0.4.1/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.1","tagName":"h2"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/dynamic/simple","content":"","keywords":"","version":"0.4.1"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.1/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.4.1","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.1/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.4.1","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/0.4.1/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了像 grid 这类 layout 函数，你会惊讶地发现其内部的 #pause 和 #meanwhile 失效了。但是你可以使用 #slide() 的 composer 参数来布局，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.4.1","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/external/pdfpc","content":"","keywords":"","version":"0.4.1"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.1/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.4.1","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.1/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.4.1","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/0.4.1/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.4.1&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.4.1","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.4.1"},{"title":"Pympress","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/external/pympress","content":"","keywords":"","version":"0.4.1"},{"title":"笔记支持​","type":1,"pageTitle":"Pympress","url":"/touying/zh/docs/0.4.1/external/pympress#笔记支持","content":" #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the speaker notes configuration, you can show it by pympress #let s = (s.methods.show-notes-on-second-screen)(self: s, right) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. #speaker-note[ + This is a speaker note. + You won't see it unless you use `#let s = (s.math.show-notes-on-second-screen)(self: s, right)` ]     然后我们就可以使用 pympress 放映了。   ","version":"0.4.1","tagName":"h2"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/cetz","content":"","keywords":"","version":"0.4.1"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.4.1/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.1","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/0.4.1/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.1","tagName":"h2"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"0.4.1"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/global-settings","content":"","keywords":"","version":"0.4.1"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.1/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"0.4.1","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.1/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"0.4.1","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/0.4.1/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"0.4.1","tagName":"h2"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) Touying 也提供了一个 touying-mitex 函数，用法如 #touying-mitex(mitex, ` f(x) &amp;= \\pause x^2 + 2x + 1 \\\\ &amp;= \\pause (x + 1)^2 \\\\ `) ","keywords":"","version":"0.4.1"},{"title":"Ctheorems","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/ctheorems","content":"Ctheorems Touying 能够与 ctheorems 包一起正常工作，你可以直接使用 ctheorems 包。 其中，你还可以使用 #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) 为 sections 和 subsections 设置 numbering。 #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/ctheorems:1.1.2&quot;: * // Register university theme #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] ","keywords":"","version":"0.4.1"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"0.4.1"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/integration/pinit","content":"","keywords":"","version":"0.4.1"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.4.1/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"0.4.1","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/0.4.1/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide, empty-slide) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"0.4.1","tagName":"h2"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/intro","content":"","keywords":"","version":"0.4.1"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.4.1","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.4.1","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"0.4.1","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.4.1","tagName":"h2"},{"title":"画廊​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#画廊","content":" Touying 通过 wiki 提供 画廊页面，您可以在其中浏览由 Touying 用户创建的优雅幻灯片。我们也鼓励您在这里贡献自己的精美幻灯片！  ","version":"0.4.1","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/0.4.1/intro#license","content":" Touying is released under the MIT license. ","version":"0.4.1","tagName":"h2"},{"title":"多文件架构","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/multi-file","content":"","keywords":"","version":"0.4.1"},{"title":"配置和内容分离​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/0.4.1/multi-file#配置和内容分离","content":" 一个最简单的 Touying 多文件架构包括三个文件：全局配置文件 globals.typ、主入口文件 main.typ 和存放内容的 content.typ 文件。  分成三个文件是由于要让 main.typ 和 content.typ 均可以引入 globals.typ，从而避免循环引用。  globals.typ 可以用于存放一些全局的自定义函数，以及对 Touying 主题进行初始化：  // globals.typ #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) // as well as some utility functions   main.typ 作为项目的主入口，通过导入 globals.typ 应用 show rules，以及通过 #include 置入 content.typ。  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;content.typ&quot;   content.typ 便是用于书写具体内容的文件了。  // content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   ","version":"0.4.1","tagName":"h2"},{"title":"多章节​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/0.4.1/multi-file#多章节","content":" 要实现多章节也十分简单，只需要新建一个 sections 目录，并将上面的 content.typ 文件移动至 sections.typ 目录即可，例如  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;sections/content.typ&quot; // #include &quot;sections/another-section.typ&quot;   和  // sections/content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   这样，您就掌握了如何使用 Touying 实现大型 slides 的多文件架构。 ","version":"0.4.1","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/progress/sections","content":"","keywords":"","version":"0.4.1"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.1/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  当然，你现在也可以直接使用 #outline(indent: 2em, title: none)。  ","version":"0.4.1","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.1/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.4.1","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/0.4.1/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.4.1","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/progress/counters","content":"","keywords":"","version":"0.4.1"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.1/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.4.1","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.1/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.4.1","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.1/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.4.1","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/0.4.1/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.4.1","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/layout","content":"","keywords":"","version":"0.4.1"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.1/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #place(top + right)[Margin→] #container[ #container[ #innerbox[Content] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer。Header 和 Footer 实际上是位于 Margin 内部。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，与 Header 类似，只不过方向相反。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )   即可。但是我们还需要解决 header 如何占据整个页面宽度的问题，在这里我们使用 negative padding 实现，例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #let margin = (x: 4em, y: 2em) // negative padding for header and footer #let negative-padding = pad.with(x: -margin.x, y: 0em) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: margin, header: negative-padding[#container[#align(top)[#innerbox(width: 100%)[Header]]]], header-ascent: 0em, footer: negative-padding[#container[#align(bottom)[#innerbox(width: 100%)[Footer]]]], footer-descent: 0em, ) #place(top + right)[↑Margin→] #container[ #container[ #innerbox[Content] ] ]     ","version":"0.4.1","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.1/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ))   Touying 会自动检测 margin.x 的值，并且判断如果 self.full-header == true，就会自动为 header 加入负填充。  同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide, empty-slide) = utils.slides(s) 之前，否则就需要重新调用 #let (slide, empty-slide) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"0.4.1","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.1/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"0.4.1","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/0.4.1/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: (1fr, auto))[ First column. ][ Second column. ]    ","version":"0.4.1","tagName":"h2"},{"title":"Aqua 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/themes/aqua","content":"","keywords":"","version":"0.4.1"},{"title":"初始化​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.1/themes/aqua#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚右侧的内容，默认为 states.slide-counter.display()。lang: 语言配置，目前只支持 &quot;en&quot; 和 &quot;zh&quot;，默认为 &quot;en&quot;,  并且 Aqua 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.1","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.1/themes/aqua#颜色主题","content":" Aqua 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#003F88&quot;), primary-light: rgb(&quot;#2159A5&quot;), primary-lightest: rgb(&quot;#F2F4F8&quot;),   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.1","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.1/themes/aqua#slide-函数族","content":" Aqua 主题提供了一系列自定义 slide 函数：  #title-slide(..args)   title-slide 会读取 self.info 里的信息用于显示。    #let outline-slide(self: none, enum-args: (:), leading: 50pt)   显示一个大纲页。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Aqua theme title: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。    #new-section-slide(title)   用给定标题开启一个新的 section。  ","version":"0.4.1","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.1/themes/aqua#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.1","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/0.4.1/themes/aqua#示例","content":" #import &quot;../lib.typ&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = The Section == Slide Title #slide[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] == Summary #align(center + horizon)[ #set text(size: 3em, weight: &quot;bold&quot;, s.colors.primary) THANKS FOR ALL ]  ","version":"0.4.1","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/start","content":"","keywords":"","version":"0.4.1"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/0.4.1/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge #import &quot;@preview/ctheorems:1.1.2&quot;: * // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. == Complex Animation #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. == CeTZ Animation CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) == Fletcher Animation Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] = Others == Side-by-side #slide(composer: (1fr, 1fr))[ First column. ][ Second column. ] == Multiple Pages #lorem(200) // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"0.4.1","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/sections","content":"","keywords":"","version":"0.4.1"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.1/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.dewdrop.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"0.4.1","tagName":"h2"},{"title":"编号​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.1/sections#编号","content":" 为了给节与小节加入编号，我们只需要使用  #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;)   即可设置默认编号为 1.1，且 section 对应的编号为 1.。  ","version":"0.4.1","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/0.4.1/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register() #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  你当然也可以使用 Typst 原生的目录：  #outline(title: none, indent: 2em)     如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"0.4.1","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/themes/dewdrop","content":"","keywords":"","version":"0.4.1"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.1","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.1","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.4.1","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.4.1","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.dewdrop.register(aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.1","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/0.4.1/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"0.4.1","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/themes/simple","content":"","keywords":"","version":"0.4.1"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.1/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.4.1","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.1/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.4.1","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.1/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.1","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/0.4.1/themes/simple#示例","content":" #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.4.1","tagName":"h2"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/themes/metropolis","content":"","keywords":"","version":"0.4.1"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.1/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.1","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.1/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.1","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.1/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.4.1","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.1/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.1","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/0.4.1/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"0.4.1","tagName":"h2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/themes/university","content":"","keywords":"","version":"0.4.1"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.1/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。display-current-section: 是否显示当前节标题。footer-columns: 底部三栏 Footer 的宽度，默认为 (25%, 1fr, 25%)。footer-a: 第一栏，默认为 self =&gt; self.info.author。footer-b: 第二栏，默认为 self =&gt; if self.info.short-title == auto { self.info.title } else { self.info.short-title }。footer-c: 第三栏，默认为  self =&gt; { h(1fr) utils.info-date(self) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number h(1fr) }   并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.1","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.1/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.1","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.1/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.4.1","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.1/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.1","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/0.4.1/themes/university#示例","content":" #import &quot;@preview/touying:0.4.1&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.4.1","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/utilities/fit-to","content":"","keywords":"","version":"0.4.1"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.4.1/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.4.1","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/0.4.1/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.4.1","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/0.4.1/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.4.1"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/changelog","content":"","keywords":"","version":"Next"},{"title":"v0.4.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v042","content":" theme(metropolis): decoupled text color with neutral-dark (Breaking change)feat: add mark-style uncover, only and alternativesfeat: add warning for styled block for slidesfeat: add warning for touying-temporary-markfeat: add markup-text for speaker-notefix: fix bug of slides  ","version":"Next","tagName":"h2"},{"title":"v0.4.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v041","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#features","content":" feat: support builtin outline and bookmarkfeat: support speaker note for dual-screenfeat: add touying-mitex functionfeat: touying offers a gallery page via wiki  ","version":"Next","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#fixes","content":" fix: add outline-slide for dewdrop themefix: fix regression of default value &quot;auto&quot; for repeat  ","version":"Next","tagName":"h3"},{"title":"Miscellaneous Improvements​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#miscellaneous-improvements","content":" feat: add list support for touying-outline functionfeat: add auto-reset-footnotefeat: add freeze-in-empty-page for better page counterfeat: add ..args for register method to capture unused arguments  ","version":"Next","tagName":"h3"},{"title":"v0.4.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v040","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#features-1","content":" feat: support #footnote[] for all themes.feat: access subslide and repeat in footer and header by self =&gt; self.subslide.feat: support numbered theorem environments by ctheorems.feat: support numbering for sections and subsections.  ","version":"Next","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#fixes-1","content":" fix: make nested includes work correctly.fix: disable multi-page slides from creating the same section multiple times.  ","version":"Next","tagName":"h3"},{"title":"Breaking changes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#breaking-changes","content":" refactor: remove self.padding and add self.full-header self.full-footer config.  ","version":"Next","tagName":"h2"},{"title":"v0.3.3​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v033","content":" template: move template to touying-aqua package, make Touying searchable in Typst Universe Packagesthemes: fix bugs in university and dewdrop themefeat: make set-show rule work without setting parameterfeat: make composer parameter more simplerfeat: add empty-slide function  ","version":"Next","tagName":"h2"},{"title":"v0.3.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v032","content":" fix critical bug: fix is-sequence function, make grid and table work correctly in touyingtheme: add aqua theme, thanks for pride7theme: make university theme more configurablerefactor: don't export variable s by default anymore, it will be extracted by register function (Breaking Change)meta: add categories and template config to typst.toml for Typst 0.11  ","version":"Next","tagName":"h2"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"Next","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v030","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#features-2","content":" better show-slides mode.support align and pad.  ","version":"Next","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#documentation","content":" Add more detailed documentation.  ","version":"Next","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#refactor","content":" simplify theme.  ","version":"Next","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#fix","content":" fix many bugs.  ","version":"Next","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v021","content":" ","version":"Next","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#features-3","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"Next","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"Next","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/next/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"Next","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/code-styles","content":"","keywords":"","version":"Next"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/next/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"Next","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/next/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide, empty-slide) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   以及 #empty-slide[] 可以创建一个没有 header 和 footer 的空 Slide。  这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"Next","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/next/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"Next","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/complex","content":"","keywords":"","version":"Next"},{"title":"标记风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/next/dynamic/complex#标记风格的函数","content":" 我们可以使用标记风格的函数，用起来十分方便。  At subslide #utils.touying-wrapper((self: none) =&gt; str(self.subslide)), we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives.   但是这种方式并非在所有情况下都能生效，例如你将 uncover 放入 grid 函数中，就会报错。  ","version":"Next","tagName":"h2"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/next/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的布局函数的限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"Next","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/next/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"Next","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/next/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"Next","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/next/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"Next","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/build-your-own-theme","content":"","keywords":"","version":"Next"},{"title":"修改已有主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#修改已有主题","content":" 如果你想在本地修改一个 Touying 内部的 themes，而不是自己从零开始创建，你可以选择通过下面的方式实现：  将 themes 目录下的 主题代码 复制到本地，例如将 themes/university.typ 复制到本地 university.typ 中。将 university.typ 文件顶部的 #import &quot;../xxx.typ&quot; 命令全部移除。向 university.typ 文件顶部中加入 #import &quot;@preview/touying:0.4.2&quot;: * 来导入所有模块。将 register 函数中的 self: s 替换成 self: themes.default.register() (重要)。  然后就可以通过  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;university.typ&quot; #let s = university.register(aspect-ratio: &quot;16-9&quot;)   的方式导入和使用主题了。  一个具体的示例：https://typst.app/project/rqRuzg0keo_ZEB5AdxjweA  ","version":"Next","tagName":"h2"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.4.2&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"Next","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。我们使用 self: themes.default.register() 的方式，获得了缺省的 self。然后我们就需要设置页面参数了。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"Next","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register() 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"Next","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"Next","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们需要设置 margin，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 2em))。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"Next","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"Next","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/next/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"Next","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/cover","content":"","keywords":"","version":"Next"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/next/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"Next","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/next/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"Next","tagName":"h2"},{"title":"hack: 处理 enum 和 list​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/next/dynamic/cover#hack-处理-enum-和-list","content":" 你会发现现有的 cover 函数无法隐藏 enum 和 list 的 mark，参考 这里，因此你可以进行 hack：  #let s = (s.methods.update-cover)(self: s, body =&gt; box(scale(x: 0%, body)))   ","version":"Next","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/next/dynamic/cover#半透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"Next","tagName":"h2"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/equation","content":"","keywords":"","version":"Next"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/next/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"Next","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/next/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"Next","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/next/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"Next","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"Next"},{"title":"Pympress","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/external/pympress","content":"","keywords":"","version":"Next"},{"title":"笔记支持​","type":1,"pageTitle":"Pympress","url":"/touying/zh/docs/next/external/pympress#��笔记支持","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the speaker notes configuration, you can show it by pympress #let s = (s.methods.show-notes-on-second-screen)(self: s, right) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. #speaker-note[ + This is a speaker note. + You won't see it unless you use `#let s = (s.math.show-notes-on-second-screen)(self: s, right)` ]     然后我们就可以使用 pympress 放映了。   ","version":"Next","tagName":"h2"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/other","content":"","keywords":"","version":"Next"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/next/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"Next","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/next/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"Next","tagName":"h2"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/dynamic/simple","content":"","keywords":"","version":"Next"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/next/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"Next","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/next/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"Next","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/next/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了像 grid 这类 layout 函数，你会惊讶地发现其内部的 #pause 和 #meanwhile 失效了。但是你可以使用 #slide() 的 composer 参数来布局，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"Next","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/external/pdfpc","content":"","keywords":"","version":"Next"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/next/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"Next","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/next/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"Next","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/next/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.4.2&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"Next","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"Next"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"Next"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/cetz","content":"","keywords":"","version":"Next"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/next/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"Next","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/next/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"Next","tagName":"h2"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/global-settings","content":"","keywords":"","version":"Next"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/next/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"Next","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/next/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"Next","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/next/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"Next","tagName":"h2"},{"title":"Ctheorems","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/ctheorems","content":"Ctheorems Touying 能够与 ctheorems 包一起正常工作，你可以直接使用 ctheorems 包。 其中，你还可以使用 #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) 为 sections 和 subsections 设置 numbering。 #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/ctheorems:1.1.2&quot;: * // Register university theme #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] ","keywords":"","version":"Next"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) Touying 也提供了一个 touying-mitex 函数，用法如 #touying-mitex(mitex, ` f(x) &amp;= \\pause x^2 + 2x + 1 \\\\ &amp;= \\pause (x + 1)^2 \\\\ `) ","keywords":"","version":"Next"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"Next"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/intro","content":"","keywords":"","version":"Next"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"Next","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"Next","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"Next","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"Next","tagName":"h2"},{"title":"画廊​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#画廊","content":" Touying 通过 wiki 提供 画廊页面，您可以在其中浏览由 Touying 用户创建的优雅幻灯片。我们也鼓励您在这里贡献自己的精美幻灯片！  ","version":"Next","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/next/intro#license","content":" Touying is released under the MIT license. ","version":"Next","tagName":"h2"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/integration/pinit","content":"","keywords":"","version":"Next"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/next/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"Next","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/next/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide, empty-slide) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"Next","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/progress/counters","content":"","keywords":"","version":"Next"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/next/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"Next","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/next/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"Next","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/next/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"Next","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/next/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"Next","tagName":"h2"},{"title":"多文件架构","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/multi-file","content":"","keywords":"","version":"Next"},{"title":"配置和内容分离​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/next/multi-file#配置和内容分离","content":" 一个最简单的 Touying 多文件架构包括三个文件：全局配置文件 globals.typ、主入口文件 main.typ 和存放内容的 content.typ 文件。  分成三个文件是由于要让 main.typ 和 content.typ 均可以引入 globals.typ，从而避免循环引用。  globals.typ 可以用于存放一些全局的自定义函数，以及对 Touying 主题进行初始化：  // globals.typ #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) // as well as some utility functions   main.typ 作为项目的主入口，通过导入 globals.typ 应用 show rules，以及通过 #include 置入 content.typ。  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;content.typ&quot;   content.typ 便是用于书写具体内容的文件了。  // content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   ","version":"Next","tagName":"h2"},{"title":"多章节​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/next/multi-file#多章节","content":" 要实现多章节也十分简单，只需要新建一个 sections 目录，并将上面的 content.typ 文件移动至 sections.typ 目录即可，例如  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;sections/content.typ&quot; // #include &quot;sections/another-section.typ&quot;   和  // sections/content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   这样，您就掌握了如何使用 Touying 实现大型 slides 的多文件架构。 ","version":"Next","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/progress/sections","content":"","keywords":"","version":"Next"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/next/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  当然，你现在也可以直接使用 #outline(indent: 2em, title: none)。  ","version":"Next","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/next/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"Next","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/next/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"Next","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/sections","content":"","keywords":"","version":"Next"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/next/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"Next","tagName":"h2"},{"title":"编号​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/next/sections#编号","content":" 为了给节与小节加入编号，我们只需要使用  #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;)   即可设置默认编号为 1.1，且 section 对应的编号为 1.。  ","version":"Next","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/next/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  你当然也可以使用 Typst 原生的目录：  #outline(title: none, indent: 2em)     如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"Next","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/layout","content":"","keywords":"","version":"Next"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/next/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #place(top + right)[Margin→] #container[ #container[ #innerbox[Content] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer。Header 和 Footer 实际上是位于 Margin 内部。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，与 Header 类似，只不过方向相反。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )   即可。但是我们还需要解决 header 如何占据整个页面宽度的问题，在这里我们使用 negative padding 实现，例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #let margin = (x: 4em, y: 2em) // negative padding for header and footer #let negative-padding = pad.with(x: -margin.x, y: 0em) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: margin, header: negative-padding[#container[#align(top)[#innerbox(width: 100%)[Header]]]], header-ascent: 0em, footer: negative-padding[#container[#align(bottom)[#innerbox(width: 100%)[Footer]]]], footer-descent: 0em, ) #place(top + right)[↑Margin→] #container[ #container[ #innerbox[Content] ] ]     ","version":"Next","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/next/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ))   Touying 会自动检测 margin.x 的值，并且判断如果 self.full-header == true，就会自动为 header 加入负填充。  同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide, empty-slide) = utils.slides(s) 之前，否则就需要重新调用 #let (slide, empty-slide) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"Next","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/next/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"Next","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/next/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: (1fr, auto))[ First column. ][ Second column. ]    ","version":"Next","tagName":"h2"},{"title":"Aqua 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/themes/aqua","content":"","keywords":"","version":"Next"},{"title":"初始化​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/next/themes/aqua#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚右侧的内容，默认为 states.slide-counter.display()。lang: 语言配置，目前只支持 &quot;en&quot; 和 &quot;zh&quot;，默认为 &quot;en&quot;,  并且 Aqua 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"Next","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/next/themes/aqua#颜色主题","content":" Aqua 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#003F88&quot;), primary-light: rgb(&quot;#2159A5&quot;), primary-lightest: rgb(&quot;#F2F4F8&quot;),   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"Next","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/next/themes/aqua#slide-函数族","content":" Aqua 主题提供了一系列自定义 slide 函数：  #title-slide(..args)   title-slide 会读取 self.info 里的信息用于显示。    #let outline-slide(self: none, enum-args: (:), leading: 50pt)   显示一个大纲页。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Aqua theme title: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。    #new-section-slide(title)   用给定标题开启一个新的 section。  ","version":"Next","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/next/themes/aqua#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/next/themes/aqua#示例","content":" #import &quot;../lib.typ&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = The Section == Slide Title #slide[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] == Summary #align(center + horizon)[ #set text(size: 3em, weight: &quot;bold&quot;, s.colors.primary) THANKS FOR ALL ]  ","version":"Next","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/start","content":"","keywords":"","version":"Next"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/next/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge #import &quot;@preview/ctheorems:1.1.2&quot;: * // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Set the speaker notes configuration // #let s = (s.methods.show-notes-on-second-screen)(self: s, right) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. #speaker-note[ + This is a speaker note. + You won't see it unless you use `#let s = (s.math.show-notes-on-second-screen)(self: s, right)` ] == Complex Animation - Mark-Style At subslide #utils.touying-wrapper((self: none) =&gt; str(self.subslide)), we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. == Complex Animation - Callback-Style #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. == CeTZ Animation CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) == Fletcher Animation Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] = Others == Side-by-side #slide(composer: (1fr, 1fr))[ First column. ][ Second column. ] == Multiple Pages #lorem(200) // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"Next","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/themes/dewdrop","content":"","keywords":"","version":"Next"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"Next","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"Next","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"Next","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"Next","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register(aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/next/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"Next","tagName":"h2"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/themes/metropolis","content":"","keywords":"","version":"Next"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/next/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"Next","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/next/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"Next","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/next/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"Next","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/next/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/next/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"Next","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/themes/simple","content":"","keywords":"","version":"Next"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/next/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"Next","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/next/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"Next","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/next/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/next/themes/simple#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"Next","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/utilities/fit-to","content":"","keywords":"","version":"Next"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/next/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"Next","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/next/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"Next","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"Next"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/next/themes/university","content":"","keywords":"","version":"Next"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/next/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。display-current-section: 是否显示当前节标题。footer-columns: 底部三栏 Footer 的宽度，默认为 (25%, 1fr, 25%)。footer-a: 第一栏，默认为 self =&gt; self.info.author。footer-b: 第二栏，默认为 self =&gt; if self.info.short-title == auto { self.info.title } else { self.info.short-title }。footer-c: 第三栏，默认为  self =&gt; { h(1fr) utils.info-date(self) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number h(1fr) }   并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"Next","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/next/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"Next","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/next/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"Next","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/next/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"Next","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/next/themes/university#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"Next","tagName":"h2"},{"title":"更新日志","type":0,"sectionRef":"#","url":"/touying/zh/docs/changelog","content":"","keywords":"","version":"0.4.2"},{"title":"v0.4.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v042","content":" theme(metropolis): decoupled text color with neutral-dark (Breaking change)feat: add mark-style uncover, only and alternativesfeat: add warning for styled block for slidesfeat: add warning for touying-temporary-markfeat: add markup-text for speaker-notefix: fix bug of slides  ","version":"0.4.2","tagName":"h2"},{"title":"v0.4.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v041","content":" ","version":"0.4.2","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#features","content":" feat: support builtin outline and bookmarkfeat: support speaker note for dual-screenfeat: add touying-mitex functionfeat: touying offers a gallery page via wiki  ","version":"0.4.2","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#fixes","content":" fix: add outline-slide for dewdrop themefix: fix regression of default value &quot;auto&quot; for repeat  ","version":"0.4.2","tagName":"h3"},{"title":"Miscellaneous Improvements​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#miscellaneous-improvements","content":" feat: add list support for touying-outline functionfeat: add auto-reset-footnotefeat: add freeze-in-empty-page for better page counterfeat: add ..args for register method to capture unused arguments  ","version":"0.4.2","tagName":"h3"},{"title":"v0.4.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v040","content":" ","version":"0.4.2","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#features-1","content":" feat: support #footnote[] for all themes.feat: access subslide and repeat in footer and header by self =&gt; self.subslide.feat: support numbered theorem environments by ctheorems.feat: support numbering for sections and subsections.  ","version":"0.4.2","tagName":"h3"},{"title":"Fixes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#fixes-1","content":" fix: make nested includes work correctly.fix: disable multi-page slides from creating the same section multiple times.  ","version":"0.4.2","tagName":"h3"},{"title":"Breaking changes​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#breaking-changes","content":" refactor: remove self.padding and add self.full-header self.full-footer config.  ","version":"0.4.2","tagName":"h2"},{"title":"v0.3.3​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v033","content":" template: move template to touying-aqua package, make Touying searchable in Typst Universe Packagesthemes: fix bugs in university and dewdrop themefeat: make set-show rule work without setting parameterfeat: make composer parameter more simplerfeat: add empty-slide function  ","version":"0.4.2","tagName":"h2"},{"title":"v0.3.2​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v032","content":" fix critical bug: fix is-sequence function, make grid and table work correctly in touyingtheme: add aqua theme, thanks for pride7theme: make university theme more configurablerefactor: don't export variable s by default anymore, it will be extracted by register function (Breaking Change)meta: add categories and template config to typst.toml for Typst 0.11  ","version":"0.4.2","tagName":"h2"},{"title":"v0.3.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v031","content":" fix some typosfix slide-level bugfix bug of pdfpc label  ","version":"0.4.2","tagName":"h2"},{"title":"v0.3.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v030","content":" ","version":"0.4.2","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#features-2","content":" better show-slides mode.support align and pad.  ","version":"0.4.2","tagName":"h3"},{"title":"Documentation​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#documentation","content":" Add more detailed documentation.  ","version":"0.4.2","tagName":"h3"},{"title":"Refactor​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#refactor","content":" simplify theme.  ","version":"0.4.2","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#fix","content":" fix many bugs.  ","version":"0.4.2","tagName":"h3"},{"title":"v0.2.1​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v021","content":" ","version":"0.4.2","tagName":"h2"},{"title":"Features​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#features-3","content":" Touying-reducer: support cetz and fletcher animationuniversity theme: add university theme  ","version":"0.4.2","tagName":"h3"},{"title":"Fix​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#fix-1","content":" fix footer progress in metropolis themefix some bugs in simple and dewdrop themesfix bug that outline does not display more than 4 sections  ","version":"0.4.2","tagName":"h3"},{"title":"v0.2.0​","type":1,"pageTitle":"更新日志","url":"/touying/zh/docs/changelog#v020","content":" Object-oriented programming: Singleton s, binding methods utils.methods(s) and (self: obj, ..) =&gt; {..} methods.Page arguments management: Instead of using #set page(..), you should use self.page-args to retrieve or set page parameters, thereby avoiding unnecessary creation of new pages.#pause for sequence content: You can use #pause at the outermost level of a slide, including inline and list.#pause for layout functions: You can use the composer parameter to add yourself layout function like utils.side-by-side, and simply use multiple pos parameters like #slide[..][..].#meanwhile for synchronous display: Provide a #meanwhile for resetting subslides counter.#pause and #meanwhile for math equation: Provide a #touying-equation(&quot;x + y pause + z&quot;) for math equation animations.Slides: Create simple slides using standard headings.Callback-style uncover, only and alternatives: Based on the concise syntax provided by Polylux, allow precise control of the timing for displaying content. You should manually control the number of subslides using the repeat parameter. Transparent cover: Enable transparent cover using oop syntax like #let s = (s.methods.enable-transparent-cover)(self: s).Handout mode: enable handout mode by #let s = (s.methods.enable-handout-mode)(self: s).Fit-to-width and fit-to-height: Fit-to-width for title in header and fit-to-height for image. utils.fit-to-width(grow: true, shrink: true, width, body)utils.fit-to-height(width: none, prescale-width: none, grow: true, shrink: true, height, body) Slides counter: states.slide-counter.display() + &quot; / &quot; + states.last-slide-number and states.touying-progress(ratio =&gt; ..).Appendix: Freeze the last-slide-number to prevent the slide number from increasing further.Sections: Touying's built-in section support can be used to display the current section title and show progress. section and subsection parameter in #slide to register a new section or subsection.states.current-section-title to get the current section.states.touying-outline or s.methods.touying-outline to display a outline of sections.states.touying-final-sections(sections =&gt; ..) for custom outline display.states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..) for powerful progress display. Navigation bar: Navigation bar like here by states.touying-progress-with-sections(..), in dewdrop theme.Pdfpc: pdfpc support and export .pdfpc file without external tool by typst query command simply. ","version":"0.4.2","tagName":"h2"},{"title":"复杂动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/complex","content":"","keywords":"","version":"0.4.2"},{"title":"标记风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/dynamic/complex#标记风格的函数","content":" 我们可以使用标记风格的函数，用起来十分方便。  At subslide #utils.touying-wrapper((self: none) =&gt; str(self.subslide)), we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives.   但是这种方式并非在所有情况下都能生效，例如你将 uncover 放入 grid 函数中，就会报错。  ","version":"0.4.2","tagName":"h2"},{"title":"回调风格的函数​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/dynamic/complex#回调风格的函数","content":" 为了避免上文提到的布局函数的限制，Touying 利用回调函数巧妙实现了总是能生效的 only、uncover 和 alternatives，具体来说，您要这样引入这三个函数：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ])     注意到了吗？我们不再是传入一个内容块，而是传入了一个参数为 self 的回调函数，随后我们通过  #let (uncover, only, alternatives) = utils.methods(self)   从 self 中取出了 only、uncover 和 alternatives 这三个函数，并在后续调用它们。  这里还有一些有趣的事实，例如 int 类型的 self.subslide 指示了当前 subslide 索引，而实际上 only、uncover 和 alternatives 函数也正是依赖 self.subslide 实现的获取当前 subslide 索引。  警告 我们手动指定了参数 repeat: 3，这代表着显示 3 张 subslides，我们需要手动指定是因为 Touying 无法探知 only、uncover 和 alternatives 需要显示多少张 subslides。  ","version":"0.4.2","tagName":"h2"},{"title":"only​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/dynamic/complex#only","content":" only 函数表示只在选定的 subslides 中「出现」，如果不出现，则会完全消失，也不会占据任何空间。也即 #only(index, body) 要么为 body 要么为 none。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  ","version":"0.4.2","tagName":"h2"},{"title":"uncover​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/dynamic/complex#uncover","content":" uncover 函数表示只在选定的 subslides 中「显示」，否则会被 cover 函数遮挡，但仍会占据原有。也即 #uncover(index, body) 要么为 body 要么为 cover(body)。  其中 index 可以是 int 类型，也可以是 &quot;2-&quot; 或 &quot;2-3&quot; 这样的 str 类型，更多用法可以参考 Polylux。  您应该也注意到了，事实上 #pause 也使用了 cover 函数，只是提供了更便利的写法，实际上它们的效果基本上是一致的。  ","version":"0.4.2","tagName":"h2"},{"title":"alternatives​","type":1,"pageTitle":"复杂动画","url":"/touying/zh/docs/dynamic/complex#alternatives","content":" alternatives 函数表示在不同的 subslides 中展示一系列不同的内容，例如  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #alternatives[Ann][Bob][Christopher] likes #alternatives[chocolate][strawberry][vanilla] ice cream. ])     如你所见，alternatives 能够自动撑开到最合适的宽度和高度，这是 only 和 uncover 所没有的能力。事实上 alternatives 还有着其他参数，例如 start: 2、repeat-last: true 和 position: center + horizon 等，更多用法可以参考 Polylux。 ","version":"0.4.2","tagName":"h2"},{"title":"代码风格","type":0,"sectionRef":"#","url":"/touying/zh/docs/code-styles","content":"","keywords":"","version":"0.4.2"},{"title":"简单风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/code-styles#简单风格","content":" 如果我们只是需要简单使用，我们可以直接在标题下输入内容，就像是在编写正常 Typst 文档一样。这里的标题有着分割页面的作用，同时我们也能正常地使用 #pause 等命令实现动画效果。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     并且你可以使用空标题 == 创建一个新页，这个技巧也有助于清除上一个标题的继续应用。  PS：我们可以使用 #slides-end 记号来标志 #show: slides 的结束。  ","version":"0.4.2","tagName":"h2"},{"title":"块风格​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/code-styles#块风格","content":" 很多时候，仅仅使用简单风格并不能实现我们需要的所有功能，为了更强大的功能和更清晰的结构，我们同样可以使用 #slide[...] 形式的块风格，其中 #slide 函数需要使用 #let (slide, empty-slide) = utils.slides(s) 语法进行解包，才能正常在 #show: slides 后使用。  例如上面的例子就可以改造成  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide #slide[ Hello, Touying! #pause Hello, Typst! ]   以及 #empty-slide[] 可以创建一个没有 header 和 footer 的空 Slide。  这样做的好处有很多：  很多时候，我们不只是需要默认的 #slide[...]，还需要 #focus-slide[...] 这些特殊的 slide 函数；不同主题的 #slide[...] 函数可能有比默认更多的参数，例如 university 主题的 #slide[...] 函数就会有着 subtitle 参数；只有 slide 函数才可以通过回调风格的内容块来使用 #only 和 #uncover 函数实现复杂的动画效果。能有着更清晰的结构，通过辨别 #slide[...] 块，我们可以很容易地分辨出 slides 的具体分页效果。  ","version":"0.4.2","tagName":"h2"},{"title":"约定优于配置​","type":1,"pageTitle":"代码风格","url":"/touying/zh/docs/code-styles#约定优于配置","content":" 你可能注意到了，在使用 simple 主题时，我们使用一级标题会自动创建一个 section slide，这是因为 simple 主题注册了一个 s.methods.touying-new-section-slide 方法，因此 touying 会默认调用这个方法。  如果我们不希望它自动创建这样一个 section slide，我们可以将这个方法删除：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = none) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     如你所见，这样就只会剩下两页，而默认的 section slide 就会消失了。  同理，我们也可以注册一个新的 section slide：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #(s.methods.touying-new-section-slide = (self: none, section, ..args) =&gt; { self = utils.empty-page(self) (s.methods.touying-slide)(self: self, section: section, { set align(center + horizon) set text(size: 2em, fill: s.colors.primary, style: &quot;italic&quot;, weight: &quot;bold&quot;) section }, ..args) }) #let (init, slides, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     同样地，我们也可以修改 s.methods.touying-new-subsection-slide 来对 subsection 做同样的事。  实际上，除了 s.methods.touying-new-section-slide，另一个特殊的 slide 函数就是 s.methods.slide 函数，它会在简单风格里没有显示使用 #slide[...] 的情况下默认被调用。  同时，由于 #slide[...] 被注册在了 s.slides = (&quot;slide&quot;,) 里，因此 section，subsection 和 title 参数会被自动传入，而其他的如 #focus-slide[...] 则不会自动传入这三个参数。  原理 实际上，你也可以不使用 #show: slides 和 utils.slides(s)，而是只使用 utils.methods(s)，例如 #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, touying-outline, slide) = utils.methods(s) #show: init #slide(section: [Title], title: [First Slide])[ Hello, Touying! #pause Hello, Typst! ] 这时候需要手动传入 section、subsection 和 title，但是会有更好的性能，适合需要更快的性能的情况，例如超过数十数百页的情形。 ","version":"0.4.2","tagName":"h2"},{"title":"Cover 函数","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/cover","content":"","keywords":"","version":"0.4.2"},{"title":"默认 Cover 函数：hide​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/dynamic/cover#默认-cover-函数hide","content":" cover 函数是保存在 s.methods.cover 的一个方法，后续 uncover 和 #pause 均会在这里取出 cover 函数来使用。  默认的 cover 函数是 hide 函数，这个函数能将内部的内容更改为不可见的，且不会影响布局。  ","version":"0.4.2","tagName":"h2"},{"title":"更新 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/dynamic/cover#更新-cover-函数","content":" 有的情况下，您想用您自己的 cover 函数，那么您可以通过  let s = (s.methods.update-cover)(self: s, is-method: true, cover-fn)   方法来设置您自己的 cover 函数，其中如果设置 is-method: false，则 Touying 会帮您将 cover-fn 包装成一个方法。  ","version":"0.4.2","tagName":"h2"},{"title":"hack: 处理 enum 和 list​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/dynamic/cover#hack-处理-enum-和-list","content":" 你会发现现有的 cover 函数无法隐藏 enum 和 list 的 mark，参考 这里，因此你可以进行 hack：  #let s = (s.methods.update-cover)(self: s, body =&gt; box(scale(x: 0%, body)))   ","version":"0.4.2","tagName":"h2"},{"title":"半透明 Cover 函数​","type":1,"pageTitle":"Cover 函数","url":"/touying/zh/docs/dynamic/cover#半��透明-cover-函数","content":" Touying 提供了半透明 Cover 函数的支持，只需要加入  #let s = (s.methods.enable-transparent-cover)(self: s)   即可开启，其中你可以通过 alpha: .. 参数调节透明度。  警告 注意，这里的 transparent-cover 并不能像 hide 一样不影响文本布局，因为里面有一层 box，因此可能会破坏页面原有的结构。  原理 enable-transparent-cover 方法定义为 #let s.methods.enable-transparent-cover = ( self: none, constructor: rgb, alpha: 85%, ) =&gt; { self.methods.cover = (self: none, body) =&gt; { utils.cover-with-rect( fill: utils.update-alpha( constructor: constructor, self.page-args.fill, alpha, ), body ) } self } 可以看出，其是通过 utils.cover-with-rect 创建了一个与背景色同色的半透明矩形遮罩，以模拟内容透明的效果，其中 constructor: rgb 和 alpha: 85% 分别表明了背景色的构造函数与透明程度。 ","version":"0.4.2","tagName":"h2"},{"title":"创建自己的主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/build-your-own-theme","content":"","keywords":"","version":"0.4.2"},{"title":"修改已有主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#修改已有主题","content":" 如果你想在本地修改一个 Touying 内部的 themes，而不是自己从零开始创建，你可以选择通过下面的方式实现：  将 themes 目录下的 主题代码 复制到本地，例如将 themes/university.typ 复制到本地 university.typ 中。将 university.typ 文件顶部的 #import &quot;../xxx.typ&quot; 命令全部移除。向 university.typ 文件顶部中加入 #import &quot;@preview/touying:0.4.2&quot;: * 来导入所有模块。将 register 函数中的 self: s 替换成 self: themes.default.register() (重要)。  然后就可以通过  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;university.typ&quot; #let s = university.register(aspect-ratio: &quot;16-9&quot;)   的方式导入和使用主题了。  一个具体的示例：https://typst.app/project/rqRuzg0keo_ZEB5AdxjweA  ","version":"0.4.2","tagName":"h2"},{"title":"导入​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#导入","content":" 取决于这个主题是你自己的，还是 Touying 的一部分，你可以用两种方式导入：  如果只是你自己使用，你可以直接导入 Touying：  #import &quot;@preview/touying:0.4.2&quot;: *   如果你希望这个主题作为 Touying 的一部分，放置在 Touying themes 目录下，那你应该将上面的导入语句改为  #import &quot;../utils/utils.typ&quot; #import &quot;../utils/states.typ&quot; #import &quot;../utils/components.typ&quot;   并且要在 Touying 的 themes/themes.typ 里加上  #import &quot;bamboo.typ&quot;   ","version":"0.4.2","tagName":"h2"},{"title":"register 函数和 init 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#register-函数和-init-方法","content":" 接下来，我们会区分 bamboo.typ 模板文件和 main.typ 文件，后者有时会被省略。  一般而言，我们制作 slides 的第一步，就是确定好字体大小和页面长宽比，因此我们需要注册一个初始化方法：  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]   如您所见，我们创建了一个 register 函数，并传入了一个 aspect-ratio 参数来设定页面长宽比。我们使用 self: themes.default.register() 的方式，获得了缺省的 self。然后我们就需要设置页面参数了。您应该已经知道了，在 Touying 中，我们不应该使用 set page(..) 来设置页面参数，而是应该使用 self.page-args += (..) 这种语法来设置，具体内容可以参考页面布局章节。  除此之外，我们还注册了一个 self.methods.init 方法，它可以用来进行一些全局的样式设置，例如在此处，我们加上了 set text(size: 20pt) 来设置文字大小。你也可以在这里放置一些额外的全局样式设置，例如 set par(justify: true) 等。由于 init 函数被放置到了 self.methods 里，是一个方法，而非普通函数，因此我们需要加上 self: none 参数才能正常使用。  如您所见，后续在 main.typ 中，我们会通过 #show: init 来应用 init 方法里面的全局样式设置，其中 init 函数是通过 utils.methods(s) 绑定并解包而来的。  如果您多加注意，您会发现 register 函数最后有一行独立的 self，这其实是代表了将修改后的 self 作为返回值返回，后续会被保存在 #let s = .. 中，因此这一行是不可或缺的。  ","version":"0.4.2","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#颜色主题","content":" 为您的 slides 挑选一个美观的颜色主题，是做好一个 slides 的关键所在。Touying 提供了内置的颜色主题支持，以尽量抹平不同主题之间的 API 差异。Touying 提供了两个维度的颜色选择，第一个维度是 neutral、primary、secondary 和 tertiary，用于区分色调，其中最常用的就是 primary 主题色；第二个维度是 default、light、lighter、lightest、dark、darker、darkest，用于区分明度。  由于我们是 Bamboo 主题，因此这里的主题色 primary 我们挑选了一个与竹子相近的颜色 rgb(&quot;#5E8B65&quot;)，并加入了中性色 neutral-lightest，neutral-darkest，分别作为背景色和字体颜色。  正如下面的代码所示，我们可以使用 self = (self.methods.colors)(self: self, ..) 方法修改颜色主题。其本质就是 self.colors += (..) 的一个包装。  #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, ) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self }   像这样添加了颜色主题后，我们就可以通过 self.colors.primary 这样的方式获取到这个颜色。  并且有一点值得注意，用户可以随时在 main.typ 里通过  #let s = (s.methods.colors)(self: s, primary: rgb(&quot;#3578B9&quot;))   这样的方式修改主题色，其中这句语句需要放在 register() 之后，以及 utils.methods(s) 之前。  这种随时更换颜色主题的内容，正是 Touying 强大可定制性的体现。  ","version":"0.4.2","tagName":"h2"},{"title":"实战：自定义 Alert 方法​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#实战自定义-alert-方法","content":" 一般而言，我们都需要提供一个 #alert[..] 函数给用户使用，其用途与 #strong[..] 类似，都是用于强调当前文本。一般 #alert[..] 会将文本颜色修改为主题色，这样看起来会更美观，这也是我们接下来要实现的目标。  我们在 register 函数里加上一句  self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it)   这句代码的意思就是将文本颜色修改为 self.colors.primary，而这里的 self 正是通过参数 self: none 传进来的，这样我们才能实时地获取到 primary 主题色。  ","version":"0.4.2","tagName":"h2"},{"title":"自定义 Header 和 Footer​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#自定义-header-和-footer","content":" 在这里，我认为您已经阅读过页面布局章节了，因此我们知道应该给 slides 加上 header 和 footer。  首先，我们先加入 self.bamboo-title = []，也就是说，我们将当前 slide 的标题作为一个成员变量 self.bamboo-title，保存在 self 里面，这样方便我们在 header 里使用，以及后续修改。同理，我们还创建了一个 self.bamboo-footer，并将 register 函数的 footer: [] 参数保存起来，用作左下角的 footer 展示。  然后值得注意的就是，我们的 header 其实是一个形如 let header(self) = { .. } 的参数为 self 的 content 函数，而不是一个单纯的 content，这样我们才能从最新的 self 内部获取到我们需要的信息，例如 self.bamboo-title。而 footer 也是同理。  里面使用到的 components.cell 其实就是 #let cell = block.with(width: 100%, height: 100%, above: 0pt, below: 0pt, breakable: false)，而 show: components.cell 也就是 components.cell(body) 的简写，footer 的 show: pad.with(.4em) 也是同理。  另一点值得注意的是，states 模块里放置了很多和计数器、状态有关的内容，例如 states.current-section-title 用于显示当前的 section，而 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number 用于显示当前页数和总页数。  以及我们发现我们会使用 utils.call-or-display(self, self.bamboo-footer) 这样的语法来显示 self.bamboo-footer，这是用于应付 self.bamboo-footer = (self) =&gt; {..} 这种情况，这样我们就能统一 content 函数和 content 的显示。  为了让 header 和 footer 正确显示，并且与正文有足够的间隔，我们需要设置 margin，如 self.page-args += (margin: (top: 4em, bottom: 1.5em, x: 2em))。  而我们还需要自定义一个 slide 方法，其中接收 slide(self: none, title: auto, ..args)，第一个 self: none 是一个方法所必须的参数，用于获取最新的 self；而第二个 title 则是用于更新 self.bamboo-title，以便在 header 中显示出来；第三个 ..args 是用于收集剩余的参数，并传到 (self.methods.touying-slide)(self: self, ..args) 里，这也是让 Touying slide 功能正常生效所必须的。并且，我们需要在 register 函数里使用 self.methods.slide = slide 注册这个方法。  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ]     ","version":"0.4.2","tagName":"h2"},{"title":"自定义特殊 Slide​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#自定义特殊-slide","content":" 我们在上面的基础 slide 的基础上，进一步加入一些特殊的 slide 函数，例如 title-slide，focus-slide 以及自定义 slides 方法。  对于 title-slide 方法，首先，我们调用了 self = utils.empty-page(self)，这个函数可以清除 self.page-args.header 和 self.page-args.footer，以及将 margin 设为 0em，得到一个空白页的效果。然后，我们可以通过 let info = self.info + args.named() 获取到 self.info 里保存的信息，也可以用函数参数里传入的 args.named() 来更新信息，便于后续以 info.title 的方式使用。具体的页面内容 body，每个 theme 都会有所不同，这里就不再过多赘述。而在最后，我们调用了 (self.methods.touying-slide)(self: self, repeat: none, body)，其中的 repeat: none 表面这个页面不需要动画效果，而传入 body 参数会将 body 的内容显示出来。  对于 new-section-slide 方法，也是同理，不过唯一要注意的是我们在 (self.methods.touying-slide)(self: self, repeat: none, section: section, body) 的参数里面多传入了一个 section: section，这是用来声明新建一个 section 的。另一点需要注意的是，我们除了 self.methods.new-section-slide = new-section-slide，还注册了 self.methods.touying-new-section-slide = new-section-slide，这样 new-section-slide 就会在碰到一级标题时自动被调用。  对于 focus-slide 方法，大部分内容也基本一致，不过值得注意的是，我们通过 self.page-args += (..) 更新了页面的背景颜色。  最后，我们还更新了 slides(self: none, title-slide: true, slide-level: 1, ..args) 方法，其中 title-slide 为 true 时，在使用 #show: slides 后会自动创建一个 title-slide；而 slide-level: 1 指明了一级标题和二级标题分别对应 section 和 title。  // bamboo.typ #import &quot;@preview/touying:0.4.2&quot;: * #let slide(self: none, title: auto, ..args) = { if title != auto { self.bamboo-title = title } (self.methods.touying-slide)(self: self, ..args) } #let title-slide(self: none, ..args) = { self = utils.empty-page(self) let info = self.info + args.named() let body = { set align(center + horizon) block( fill: self.colors.primary, width: 80%, inset: (y: 1em), radius: 1em, text(size: 2em, fill: self.colors.neutral-lightest, weight: &quot;bold&quot;, info.title) ) set text(fill: self.colors.neutral-darkest) if info.author != none { block(info.author) } if info.date != none { block(if type(info.date) == datetime { info.date.display(self.datetime-format) } else { info.date }) } } (self.methods.touying-slide)(self: self, repeat: none, body) } #let new-section-slide(self: none, section) = { self = utils.empty-page(self) let body = { set align(center + horizon) set text(size: 2em, fill: self.colors.primary, weight: &quot;bold&quot;, style: &quot;italic&quot;) section } (self.methods.touying-slide)(self: self, repeat: none, section: section, body) } #let focus-slide(self: none, body) = { self = utils.empty-page(self) self.page-args += ( fill: self.colors.primary, margin: 2em, ) set text(fill: self.colors.neutral-lightest, size: 2em) (self.methods.touying-slide)(self: self, repeat: none, align(horizon + center, body)) } #let slides(self: none, title-slide: true, slide-level: 1, ..args) = { if title-slide { (self.methods.title-slide)(self: self) } (self.methods.touying-slides)(self: self, slide-level: slide-level, ..args) } #let register( self: themes.default.register(), aspect-ratio: &quot;16-9&quot;, footer: [], ) = { // color theme self = (self.methods.colors)( self: self, primary: rgb(&quot;#5E8B65&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), neutral-darkest: rgb(&quot;#000000&quot;), ) // variables for later use self.bamboo-title = [] self.bamboo-footer = footer // set page let header(self) = { set align(top) show: components.cell.with(fill: self.colors.primary, inset: 1em) set align(horizon) set text(fill: self.colors.neutral-lightest, size: .7em) states.current-section-title linebreak() set text(size: 1.5em) utils.call-or-display(self, self.bamboo-title) } let footer(self) = { set align(bottom) show: pad.with(.4em) set text(fill: self.colors.neutral-darkest, size: .8em) utils.call-or-display(self, self.bamboo-footer) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number } self.page-args += ( paper: &quot;presentation-&quot; + aspect-ratio, header: header, footer: footer, margin: (top: 4em, bottom: 1.5em, x: 2em), ) // register methods self.methods.slide = slide self.methods.title-slide = title-slide self.methods.new-section-slide = new-section-slide self.methods.touying-new-section-slide = new-section-slide self.methods.focus-slide = focus-slide self.methods.slides = slides self.methods.alert = (self: none, it) =&gt; text(fill: self.colors.primary, it) self.methods.init = (self: none, body) =&gt; { set text(size: 20pt) body } self } // main.typ #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;bamboo.typ&quot; #let s = bamboo.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide) = utils.slides(s) #show: slides = First Section == First Slide #slide[ A slide with a title and an *important* information. ] #focus-slide[ Focus on it! ]     ","version":"0.4.2","tagName":"h2"},{"title":"总结​","type":1,"pageTitle":"创建自己的主题","url":"/touying/zh/docs/build-your-own-theme#总结","content":" 至此，我们就已经创建了一个简洁又美观的主题了。也许你会觉得，Touying 引入的概念过于丰富了，以至于让人一时很难轻易接受。这是正常的，在强大的功能与简洁的概念之间，Touying 选择了前者。但是也正是得益于 Touying 这种大而全的统一理念，你可以很容易地在不同的主题之间抽离出共通之处，并将你学到的概念迁移到另一个主题上。亦或者，你可以很轻易地保存全局变量，或者更改已有的主题，例如全局保存主题颜色，替换掉 slides 的 header，或者添加一两个 Logo 等，这也正是 Touying 解耦与面向对象编程带来的好处。 ","version":"0.4.2","tagName":"h2"},{"title":"创建讲义","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/handout","content":"创建讲义 在看幻灯片、听课的同时，听众往往会希望有一个讲义，以便能够回顾理解困难的地方，所以，作者最好能给听众提供这样一份讲义，如果能在听课前提供更好。 讲义模式与普通模式的区别是，其不需要过于繁杂的动画效果，因此只会保留每个 slide 的最后一张 subslide。 开启讲义模式是很简单的： #let s = (s.methods.enable-handout-mode)(self: s) ","keywords":"","version":"0.4.2"},{"title":"其他动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/other","content":"","keywords":"","version":"0.4.2"},{"title":"简单动画​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/dynamic/other#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.2","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"其他动画","url":"/touying/zh/docs/dynamic/other#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.2","tagName":"h2"},{"title":"数学公式动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/equation","content":"","keywords":"","version":"0.4.2"},{"title":"简单动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/dynamic/equation#简单动画","content":" 让我们先来看一个例子：  #slide[ Touying equation with pause: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Touying equation is very simple. ]     我们使用 touying-equation 函数来实现在数学公式文本内部使用 pause 和 meanwhile（事实上，你也能用 #pause 或者 #pause;）。  正如你料想的一样，数学公式会分步显示，这很适合给让演讲者演示自己的数学公式推理思路。  警告 虽然 touying-equation 函数很便利，但是您需要时刻注意，touying-equation 并不会做复杂的语法分析，只是单纯地正则表达式分割字符串，因此您不应在 display(..) 这类函数内部使用 pause 或 meanwhile！  ","version":"0.4.2","tagName":"h2"},{"title":"复杂动画​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/dynamic/equation#复杂动画","content":" 事实上，我们也可以在 touying-equation 内部使用 only、uncover 和 alternatives，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) #touying-equation(scope: (uncover: uncover), ` f(x) &amp;= pause x^2 + 2x + uncover(&quot;3-&quot;, 1) \\ &amp;= pause (x + 1)^2 \\ `) ])     我们可以在 touying-equation 的 scope 参数中将我们需要用到的函数传递进去，例如这里的 uncover。  ","version":"0.4.2","tagName":"h2"},{"title":"参数​","type":1,"pageTitle":"数学公式动画","url":"/touying/zh/docs/dynamic/equation#参数","content":" touying-equation 的函数定义为  #let touying-equation(block: true, numbering: none, supplement: auto, scope: (:), body) = { .. }   因此，我们可以像使用普通数学公式一样，为 touying-equation 传入 block、numbering 和 supplement 参数。 ","version":"0.4.2","tagName":"h2"},{"title":"Typst Preview","type":0,"sectionRef":"#","url":"/touying/zh/docs/external/typst-preview","content":"Typst Preview VS Code 的 Typst Preview 插件提供了优秀的 slide mode，我们可以用其预览和放映 slides。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in slide mode，就可以打开 slide mode 的预览。 按下 Ctrl/Cmd + Shift + P，并输入 Typst Preview: Preview current file in browser and slide mode，就可以在浏览器打开 slide mode。 这时候你可以按下 F11 之类的键，进入浏览器的全屏模式，就可以用于 slides 放映了。 由于 Typst Preview 是基于 SVG 的，因此可以播放 GIF 动图，这对于动态 slides 很有帮助。","keywords":"","version":"0.4.2"},{"title":"简单动画","type":0,"sectionRef":"#","url":"/touying/zh/docs/dynamic/simple","content":"","keywords":"","version":"0.4.2"},{"title":"pause​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/dynamic/simple#pause","content":" #pause 的用途很简单，就是用于将后续的内容放到下一张 subslide 中，并且可以使用多个 #pause 以创建多张 subslides，一个简单的例子：  #slide[ First #pause Second #pause Third ]     这个例子将会创建三张 subslides，逐渐地将内容展示出来。  如你所见，#pause 既可以放在行内，也可以放在单独的一行。  ","version":"0.4.2","tagName":"h2"},{"title":"meanwhile​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/dynamic/simple#meanwhile","content":" 有些情况下，我们需要在 #pause 的同时展示一些其他内容，这时候我们就可以用 #meanwhile。  #slide[ First #pause Second #meanwhile Third #pause Fourth ]     这个例子只会创建两张 subslides，并且 &quot;First&quot; 和 &quot;Third&quot; 同时显示，&quot;Second&quot; 和 &quot;Fourth&quot; 同时显示。  ","version":"0.4.2","tagName":"h2"},{"title":"如何处理 set-show rules?​","type":1,"pageTitle":"简单动画","url":"/touying/zh/docs/dynamic/simple#如何处理-set-show-rules","content":" 如果你在 slide[..] 里面使用了像 grid 这类 layout 函数，你会惊讶地发现其内部的 #pause 和 #meanwhile 失效了。但是你可以使用 #slide() 的 composer 参数来布局，大部分情况下都应该能满足需求。  原理 Touying 不依赖 counter 和 locate 来实现 #pause，而是用 Typst 脚本写了一个 parser。它会将输入内容块作为 sequence 解析，然后改造重组这个 sequence 为我们需要的一系列 subslides。 ","version":"0.4.2","tagName":"h2"},{"title":"pdfpc","type":0,"sectionRef":"#","url":"/touying/zh/docs/external/pdfpc","content":"","keywords":"","version":"0.4.2"},{"title":"加入 Metadata​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/external/pdfpc#加入-metadata","content":" Touying 与 Polylux 保持一致，以避免 API 之间的冲突。  例如，你可以通过 #pdfpc.speaker-note(&quot;This is a note that only the speaker will see.&quot;) 加入 notes。  ","version":"0.4.2","tagName":"h2"},{"title":"pdfpc 配置​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/external/pdfpc#pdfpc-配置","content":" 为了加入 pdfpc 配置，你可以使用  #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))   加入对应的配置，具体配置方法可以参考 Polylux。  ","version":"0.4.2","tagName":"h2"},{"title":"输出 .pdfpc 文件​","type":1,"pageTitle":"pdfpc","url":"/touying/zh/docs/external/pdfpc#输出-pdfpc-文件","content":" 假设你的文档为 ./example.typ，则你可以通过  typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc   直接导出 .pdfpc 文件。  借助 Touying 与 Polylux 的兼容性，你可以让 Polylux 也支持直接导出，只需要加入下面的代码即可。  #import &quot;@preview/touying:0.4.2&quot; #locate(loc =&gt; touying.pdfpc.pdfpc-file(loc))  ","version":"0.4.2","tagName":"h2"},{"title":"Pympress","type":0,"sectionRef":"#","url":"/touying/zh/docs/external/pympress","content":"","keywords":"","version":"0.4.2"},{"title":"笔记支持​","type":1,"pageTitle":"Pympress","url":"/touying/zh/docs/external/pympress#笔记支持","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the speaker notes configuration, you can show it by pympress #let s = (s.methods.show-notes-on-second-screen)(self: s, right) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. #speaker-note[ + This is a speaker note. + You won't see it unless you use `#let s = (s.math.show-notes-on-second-screen)(self: s, right)` ]     然后我们就可以使用 pympress 放映了。   ","version":"0.4.2","tagName":"h2"},{"title":"Ctheorems","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/ctheorems","content":"Ctheorems Touying 能够与 ctheorems 包一起正常工作，你可以直接使用 ctheorems 包。 其中，你还可以使用 #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) 为 sections 和 subsections 设置 numbering。 #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/ctheorems:1.1.2&quot;: * // Register university theme #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] ","keywords":"","version":"0.4.2"},{"title":"CeTZ","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/cetz","content":"","keywords":"","version":"0.4.2"},{"title":"简单动画​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/integration/cetz#简单动画","content":" 一个例子：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ]     ","version":"0.4.2","tagName":"h2"},{"title":"only 与 uncover​","type":1,"pageTitle":"CeTZ","url":"/touying/zh/docs/integration/cetz#only-与-uncover","content":" 事实上，我们也可以在 cetz 内部使用 only 和 uncover，只是需要一点技巧：  #slide(repeat: 3, self =&gt; [ #let (uncover, only) = utils.methods(self) Cetz in Touying in subslide #self.subslide: #cetz.canvas({ import cetz.draw: * let self = (self.methods.update-cover)(self: self, hide.with(bounds: true)) let (uncover,) = utils.methods(self) rect((0,0), (5,5)) uncover(&quot;2-3&quot;, { rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) }) only(3, line((0,0), (2.5, 2.5), name: &quot;line&quot;)) }) ])  ","version":"0.4.2","tagName":"h2"},{"title":"全局设置","type":0,"sectionRef":"#","url":"/touying/zh/docs/global-settings","content":"","keywords":"","version":"0.4.2"},{"title":"全局样式​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/global-settings#全局样式","content":" 对 Touying 而言，全局样式即为需要应用到所有地方的 set rules 或 show rules，例如 #set text(size: 20pt)。  其中，Touying 的主题会封装一些自己的全局样式，他们会被放在 #show: init 中，例如 university 主题就封装了  self.methods.init = (self: none, body) =&gt; { set text(size: 25pt) show footnote.entry: set text(size: .6em) body }   如果你并非一个主题制作者，而只是想给你的 slides 添加一些自己的全局样式，你可以简单地将它们放在 #show: init 之后，以及 #show: slides 之前，例如 metropolis 主题就推荐你自行加入以下全局样式：  #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init // global styles #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   但是注意，你不应该使用 #set page(..)，而是应该修改 s.page-args 和 s.padding，例如  #(s.page-args += ( margin: (x: 0em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )) #(s.padding += (x: 4em, y: 0em))   ","version":"0.4.2","tagName":"h2"},{"title":"全局信息​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/global-settings#全局信息","content":" 就像 Beamer 一样，Touying 通过 OOP 风格的统一 API 设计，能够帮助您更好地维护全局信息，让您可以方便地在不同的主题之间切换，全局信息就是一个很典型的例子。  你可以通过  #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], )   分别设置 slides 的标题、副标题、作者、日期和机构信息。在后续，你就可以通过 s.info 或 self.info 这样的方式访问它们。  这些信息一般会在主题的 title-slide、header 和 footer 被使用到，例如 #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution)。  其中 date 可以接收 datetime 格式和 content 格式，并且 datetime 格式的日期显示格式，可以通过  #let s = (s.methods.datetime-format)(self: s, &quot;[year]-[month]-[day]&quot;)   的方式更改。  原理 在这里，我们会稍微引入一点 Touying 的 OOP 概念。 您应该知道，Typst 是一个支持增量渲染的排版语言，也就是说，Typst 会缓存之前的函数调用结果，这就要求 Typst 里只有纯函数，即无法改变外部变量的函数。因此我们很难真正意义上地像 LaTeX 那样修改一个全局变量。即使是使用 state 或 counter，也需要使用 locate 与回调函数来获取里面的值，且实际上这种方式会对性能有很大的影响。 Touying 并没有使用 state 和 counter，也没有违反 Typst 纯函数的原则，而是使用了一种巧妙的方式，并以面向对象风格的代码，维护了一个全局单例 s。在 Touying 中，一个对象指拥有自己的成员变量和方法的 Typst 字典，并且我们约定方法均有一个命名参数 self 用于传入对象自身，并且方法均放在 .methods 域里。有了这个理念，我们就不难写出更新 info 的方法了： #let s = ( info: (:), methods: ( // update info info: (self: none, ..args) =&gt; { self.info += args.named() self }, ) ) #let s = (s.methods.info)(self: s, title: [title]) Title is #s.info.title 这样，你也能够理解 utils.methods() 函数的用途了：将 self 绑定到 s 的所有方法上并返回，并通过解包语法简化后续的使用。 #let (init, slides, alert) = utils.methods(s)   ","version":"0.4.2","tagName":"h2"},{"title":"状态初始化​","type":1,"pageTitle":"全局设置","url":"/touying/zh/docs/global-settings#状态初始化","content":" 一般而言，上面的两种方式就已经足够用于加入全局设置了，但是仍然会有部分情况，我们需要初始化 counters 或 states。如果将这些代码放在 #show: slides 之前，就会创建一个空白页，这是我们不想看见的，因此这时候我们就可以使用 s.methods.append-preamble 方法。例如在使用 codly 包的时候：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ]     又或者是进行 Pdfpc 的配置的时候：  // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), ))  ","version":"0.4.2","tagName":"h2"},{"title":"Codly","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/codly","content":"Codly 在使用 codly 的时候，我们应该使用 s.methods.append-preamble 方法进行初始化。 #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/codly:0.2.0&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.append-preamble)(self: s)[ #codly(languages: ( rust: (name: &quot;Rust&quot;, icon: &quot;\\u{fa53}&quot;, color: rgb(&quot;#CE412B&quot;)), )) ] #let (init, slides) = utils.methods(s) #show heading.where(level: 2): set block(below: 1em) #show: init #show: codly-init.with() #let (slide, empty-slide) = utils.slides(s) #show: slides #slide[ == First slide #raw(lang: &quot;rust&quot;, block: true, `pub fn main() { println!(&quot;Hello, world!&quot;); }`.text) ] ","keywords":"","version":"0.4.2"},{"title":"MiTeX","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/mitex","content":"MiTeX 在创建 slides 的过程中，往往我们已经有了一个 LaTeX 数学公式，只是想贴到 slides 的里面，而不想把它转写成 Typst 数学公式，这时候我们就可以用 MiTeX 了。 示例： #import &quot;@preview/mitex:0.2.3&quot;: * Write inline equations like #mi(&quot;x&quot;) or #mi[y]. Also block equations (this case is from #text(blue.lighten(20%), link(&quot;https://katex.org/&quot;)[katex.org])): #mitex(` \\newcommand{\\f}[2]{#1f(#2)} \\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi\\,e^{2 \\pi i \\xi x} \\,d\\xi `) Touying 也提供了一个 touying-mitex 函数，用法如 #touying-mitex(mitex, ` f(x) &amp;= \\pause x^2 + 2x + 1 \\\\ &amp;= \\pause (x + 1)^2 \\\\ `) ","keywords":"","version":"0.4.2"},{"title":"Fletcher","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/fletcher","content":"Fletcher Touying 提供了 touying-reducer，它能为 fletcher 加入 pause 和 meanwhile 动画。 一个例子： #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(title-slide: false, outline-slide: false) // cetz animation #slide[ Cetz in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) ] // fletcher animation #slide[ Fletcher in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) ] ","keywords":"","version":"0.4.2"},{"title":"Touying 介绍","type":0,"sectionRef":"#","url":"/touying/zh/docs/intro","content":"","keywords":"","version":"0.4.2"},{"title":"为什么使用 Touying​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#为什么使用-touying","content":" 相较于 PowerPoint，Touying 并非「所示即所得的」，你可以使用一种「内容与样式分离」的方式编写你的 slides，尤其是 Typst 作为一个新兴的排版语言，提供了简洁但强大的语法，对于代码块、数学公式和定理等内容有着更好的支持。另一个优势是，在有着模板的情况下，用 Touying 编写 slides 要比 PowerPoint 快得多。因此 Touying 相较于 PowerPoint，更适合有着「科研写作」需求的用户使用。相较于 Markdown Slides，Touying 所依托的 Typst 有着更强大的排版控制能力，例如页眉、页脚、布局和便捷的自定义函数，而这是 Markdown 很难具备、或者说很难做好的能力。并且 Touying 提供了 #pause 和 #meanwhile 标记，提供了更为便捷的动态 slides 能力。相较于 Beamer，Touying 有着更快的编译速度、更简洁的语法，以及更简单的自定义主题的能力。相较于 Beamer 动辄几秒几十秒的编译时间，Touying 的编译速度基本上能够维持在几毫秒几十毫秒。并且 Touying 的语法相较于 Beamer 更为简洁，也更容易更改模板主题，以及创建你自己的模板。在功能上，Touying 支持了 Beamer 大部分的能力，并且还提供了一些 Beamer 所没有的便利功能。相较于 Polylux，Touying 提供了一种 oop 风格的语法，能够通过全局单例模拟提供「全局变量」的能力，进而可以方便地编写主题。并且 Touying 并不依赖 counter 和 locate 来实现 #pause，因此能有更好的性能。Touying 自身定位是一个社区驱动的项目（我们欢迎更多的人加入），并且不会过分强调维持 API 的一致性，而是选择维护多个版本的文档，因而能够提供更多新颖但强大的功能。  ","version":"0.4.2","tagName":"h2"},{"title":"名称来源​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#名称来源","content":" Touying 取自中文里的「投影」，在英文中意为 project。相较而言，LaTeX 中的 beamer 就是德文的投影仪的意思。  ","version":"0.4.2","tagName":"h2"},{"title":"关于文档​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#关于文档","content":" 这个文档通过 Docusaurus 驱动开发，我们将会为 Touying 维持英文和中文版本的文档，并且每个大版本维护一份文档，以便你随时可以查阅旧版本的 Touying 文档，并且可以更容易地迁移到新版本。  Docusaurus 创建新版本：  npm run docusaurus docs:version 0.y.x   Docusaurus 多语言：  npm run start -- --locale zh   ","version":"0.4.2","tagName":"h2"},{"title":"贡献​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#贡献","content":" Touying 是免费、开源且社区驱动的。如果你感兴趣，你可以随时访问 GitHub 并提出 issue 或 PR，我们也同样欢迎你加入 touying-typ 组织。  ","version":"0.4.2","tagName":"h2"},{"title":"画廊​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#画廊","content":" Touying 通过 wiki 提供 画廊页面，您可以在其中浏览由 Touying 用户创建的优雅幻灯片。我们也鼓励您在这里贡献自己的精美幻灯片！  ","version":"0.4.2","tagName":"h2"},{"title":"License​","type":1,"pageTitle":"Touying 介绍","url":"/touying/zh/docs/intro#license","content":" Touying is released under the MIT license. ","version":"0.4.2","tagName":"h2"},{"title":"Pinit","type":0,"sectionRef":"#","url":"/touying/zh/docs/integration/pinit","content":"","keywords":"","version":"0.4.2"},{"title":"简单示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/integration/pinit#简单示例","content":" #import &quot;@preview/pinit:0.1.3&quot;: * #set text(size: 24pt) A simple #pin(1)highlighted text#pin(2). #pinit-highlight(1, 2) #pinit-point-from(2)[It is simple.]     另一个 示例：    ","version":"0.4.2","tagName":"h2"},{"title":"复杂示例​","type":1,"pageTitle":"Pinit","url":"/touying/zh/docs/integration/pinit#复杂示例","content":"   一个与 Touying 共同使用的示例：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/pinit:0.1.3&quot;: * #(s.page-args.paper = &quot;presentation-4-3&quot;) #let (init, slides) = utils.methods(s) #show: init #set text(size: 20pt, font: &quot;Calibri&quot;, ligatures: false) #show heading: set text(weight: &quot;regular&quot;) #show heading: set block(above: 1.4em, below: 1em) #show heading.where(level: 1): set text(size: 1.5em) // Useful functions #let crimson = rgb(&quot;#c00000&quot;) #let greybox(..args, body) = rect(fill: luma(95%), stroke: 0.5pt, inset: 0pt, outset: 10pt, ..args, body) #let redbold(body) = { set text(fill: crimson, weight: &quot;bold&quot;) body } #let blueit(body) = { set text(fill: blue) body } #let (slide, empty-slide) = utils.slides(s) #show: slides // Main body #slide(self =&gt; [ #let (uncover, only) = utils.methods(self) = Asymptotic Notation: $O$ Use #pin(&quot;h1&quot;)asymptotic notations#pin(&quot;h2&quot;) to describe asymptotic efficiency of algorithms. (Ignore constant coefficients and lower-order terms.) #pause #greybox[ Given a function $g(n)$, we denote by $O(g(n))$ the following *set of functions*: #redbold(${f(n): &quot;exists&quot; c &gt; 0 &quot;and&quot; n_0 &gt; 0, &quot;such that&quot; f(n) &lt;= c dot g(n) &quot;for all&quot; n &gt;= n_0}$) ] #pinit-highlight(&quot;h1&quot;, &quot;h2&quot;) #pause $f(n) = O(g(n))$: #pin(1)$f(n)$ is *asymptotically smaller* than $g(n)$.#pin(2) // #absolute-place(dx: 550pt, dy: 320pt, image(width: 25%, &quot;asymptotic.png&quot;)) #pause $f(n) redbold(in) O(g(n))$: $f(n)$ is *asymptotically* #redbold[at most] $g(n)$. #only(&quot;4-&quot;, pinit-line(stroke: 3pt + crimson, start-dy: -0.25em, end-dy: -0.25em, 1, 2)) #pause #block[Insertion Sort as an #pin(&quot;r1&quot;)example#pin(&quot;r2&quot;):] - Best Case: $T(n) approx c n + c' n - c''$ #pin(3) - Worst case: $T(n) approx c n + (c' \\/ 2) n^2 - c''$ #pin(4) #pinit-rect(&quot;r1&quot;, &quot;r2&quot;) #pause #pinit-place(3, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pinit-place(4, dx: 15pt, dy: -15pt)[#redbold[$T(n) = O(n)$]] #pause #blueit[Q: Is $n^(3) = O(n^2)$#pin(&quot;que&quot;)? How to prove your answer#pin(&quot;ans&quot;)?] #pause #only(&quot;8-&quot;, pinit-point-to(&quot;que&quot;, fill: crimson, redbold[No.])) #only(&quot;8-&quot;, pinit-point-from(&quot;ans&quot;, body-dx: -150pt)[ Show that the equation $(3/2)^n &gt;= c$ \\ has infinitely many solutions for $n$. ]) ])    ","version":"0.4.2","tagName":"h2"},{"title":"Touying 的计数器","type":0,"sectionRef":"#","url":"/touying/zh/docs/progress/counters","content":"","keywords":"","version":"0.4.2"},{"title":"slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/progress/counters#slide-计数器","content":" 你可以通过 states.slide-counter 获取 slide 计数器，并且通过 states.slide-counter.display() 展示当前 slide 的序号。  ","version":"0.4.2","tagName":"h2"},{"title":"last-slide 计数器​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/progress/counters#last-slide-计数器","content":" 因为有些情形下，我们需要为 slides 加入后记，因此就有了冻结 last-slide 计数器的需求，因此这里维护了第二个计数器。  我们可以使用 states.last-slide-number 展示后记前最后一张 slide 的序号。  ","version":"0.4.2","tagName":"h2"},{"title":"进度​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/progress/counters#进度","content":" 我们可以使用  #states.touying-progress(ratio =&gt; ..)   来显示当前的进度。  ","version":"0.4.2","tagName":"h2"},{"title":"后记​","type":1,"pageTitle":"Touying 的计数器","url":"/touying/zh/docs/progress/counters#后记","content":" 你可以使用  // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.methods(s) #slide[ appendix ]   语法进入后记。  并且 #let s = (s.methods.appendix-in-outline)(self: s, false) 可以让后记的 section 不显示在大纲中。 ","version":"0.4.2","tagName":"h2"},{"title":"多文件架构","type":0,"sectionRef":"#","url":"/touying/zh/docs/multi-file","content":"","keywords":"","version":"0.4.2"},{"title":"配置和内容分离​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/multi-file#配置和内容分离","content":" 一个最简单的 Touying 多文件架构包括三个文件：全局配置文件 globals.typ、主入口文件 main.typ 和存放内容的 content.typ 文件。  分成三个文件是由于要让 main.typ 和 content.typ 均可以引入 globals.typ，从而避免循环引用。  globals.typ 可以用于存放一些全局的自定义函数，以及对 Touying 主题进行初始化：  // globals.typ #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) // as well as some utility functions   main.typ 作为项目的主入口，通过导入 globals.typ 应用 show rules，以及通过 #include 置入 content.typ。  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;content.typ&quot;   content.typ 便是用于书写具体内容的文件了。  // content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   ","version":"0.4.2","tagName":"h2"},{"title":"多章节​","type":1,"pageTitle":"多文件架构","url":"/touying/zh/docs/multi-file#多章节","content":" 要实现多章节也十分简单，只需要新建一个 sections 目录，并将上面的 content.typ 文件移动至 sections.typ 目录即可，例如  // main.typ #import &quot;/globals.typ&quot;: * #show: init #show strong: alert #show: slides #include &quot;sections/content.typ&quot; // #include &quot;sections/another-section.typ&quot;   和  // sections/content.typ #import &quot;/globals.typ&quot;: * = The Section == Slide Title Hello, Touying! #focus-slide[ Focus on me. ]   这样，您就掌握了如何使用 Touying 实现大型 slides 的多文件架构。 ","version":"0.4.2","tagName":"h2"},{"title":"页面布局","type":0,"sectionRef":"#","url":"/touying/zh/docs/layout","content":"","keywords":"","version":"0.4.2"},{"title":"基础概念​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/layout#基础概念","content":" 要想使用 Typst 制作一个样式美观的 slides，正确理解 Typst 的页面模型是必须的，如果你不关心自定义页面样式，你可以选择跳过这部分，否则还是推荐看一遍这部分。  下面我们通过一个具体的例子来说明 Typst 的默认页面模型。  #let container = rect.with(height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(stroke: (dash: &quot;dashed&quot;)) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, header: container[#innerbox[Header]], header-ascent: 30%, footer: container[#innerbox[Footer]], footer-descent: 30%, ) #place(top + right)[Margin→] #container[ #container[ #innerbox[Content] ] ]     我们需要区分以下概念：  Model: Typst 拥有与 CSS Box Model 类似的模型，分为 Margin、Padding 和 Content，但其中 padding 并非 set page(..) 的属性，而是我们手动添加 #pad(..) 得到的。Margin: 页边距，分为上下左右四个方向，是 Typst 页面模型的核心，其他属性都会受到页边距的影响，尤其是 Header 和 Footer。Header 和 Footer 实际上是位于 Margin 内部。Header: Header 是页面顶部的内容，又分为 container 和 innerbox。我们可以注意到 header container 和 padding 的边缘并不贴合，而是也有一定的空隙，这个空隙实际上就是 header-ascent: 30%，而这里的百分比是相对于 margin-top 而言的。并且，我们注意到 header innerbox 实际上位于 header container 左下角，也即 innerbox 实际上默认有属性 #set align(left + bottom)。Footer: Footer 是页面底部的内容，与 Header 类似，只不过方向相反。Place: place 函数可以实现绝对定位，在不影响父容器内其他元素的情况下，相对于父容器来定位，并且可以传入 alignment、dx 和 dy，很适合用来放置一些修饰元素，例如 Logo 之类的图片。  因此，要将 Typst 应用到制作 slides 上，我们只需要设置  #set page( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, )   即可。但是我们还需要解决 header 如何占据整个页面宽度的问题，在这里我们使用 negative padding 实现，例如我们有  #let container = rect.with(stroke: (dash: &quot;dashed&quot;), height: 100%, width: 100%, inset: 0pt) #let innerbox = rect.with(fill: rgb(&quot;#d0d0d0&quot;)) #let margin = (x: 4em, y: 2em) // negative padding for header and footer #let negative-padding = pad.with(x: -margin.x, y: 0em) #set text(size: 30pt) #set page( paper: &quot;presentation-16-9&quot;, margin: margin, header: negative-padding[#container[#align(top)[#innerbox(width: 100%)[Header]]]], header-ascent: 0em, footer: negative-padding[#container[#align(bottom)[#innerbox(width: 100%)[Footer]]]], footer-descent: 0em, ) #place(top + right)[↑Margin→] #container[ #container[ #innerbox[Content] ] ]     ","version":"0.4.2","tagName":"h2"},{"title":"页面管理​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/layout#页面管理","content":" 由于 Typst 中使用 set page(..) 命令来修改页面参数，会导致创建一个新的页面，而不能修改当前页面，因此 Touying 选择维护一个 s.page-args 成员变量和一个 s.padding 成员变量，只在 Touying 自己创建新 slide 时才会自己应用这些参数，因此用户只需要关注 s.page-args 和 s.padding 即可。  例如，上面的例子就可以改成  #(s.page-args += ( margin: (x: 4em, y: 2em), header: align(top)[Header], footer: align(bottom)[Footer], header-ascent: 0em, footer-descent: 0em, ))   Touying 会自动检测 margin.x 的值，并且判断如果 self.full-header == true，就会自动为 header 加入负填充。  同理，如果你对某个主题的 header 或 footer 样式不满意，你也可以通过  #(s.page-args.footer = [Custom Footer])   这样方式进行更换。不过需要注意的是，如果这样更换了页面参数，你需要将其放在 #let (slide, empty-slide) = utils.slides(s) 之前，否则就需要重新调用 #let (slide, empty-slide) = utils.slides(s)。  警告 因此，你不应该自己使用 set page(..) 命令，而是应该修改 s 内部的 s.page-args 成员变量。  借助这种方式，我们也可以通过 s.page-args 实时查询当前页面的参数，这对一些需要获取页边距或当前页面背景颜色的函数很有用，例如 transparent-cover。这里就部分等价于 context get rule，而且实际上用起来会更方便。  ","version":"0.4.2","tagName":"h2"},{"title":"应用：添加 Logo​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/layout#应用添加-logo","content":" 为 slides 添加一个 Logo 是及其普遍，但是又及其多变的一个需求。其中的难点在于，所需要的 Logo 大小和位置往往因人而异。因此，Touying 的主题大部分都不包含 Logo 的配置选项。但借助本章节提到的页面布局的概念，我们知道可以在 header 或 footer 中使用 place 函数来放置 Logo 图片。  例如，我们决定给 metropolis 主题加入 GitHub 的图标，我们可以这样实现：  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/octique:0.1.0&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;) #(s.page-args.header = self =&gt; { // display the original header utils.call-or-display(self, s.page-args.header) // place logo to top-right place(top + right, dx: -0.5em, dy: 0.3em)[ #octique(&quot;mark-github&quot;, color: rgb(&quot;#fafafa&quot;), width: 1.5em, height: 1.5em) ] }) #let (init, slide) = utils.methods(s) #show: init #slide(title: [Title])[ Logo example. ]     其中 utils.call-or-display(self, body) 可以用于显示 body 为 content 或 body 为形如 self =&gt; content 形式的回调函数。  ","version":"0.4.2","tagName":"h2"},{"title":"页面分栏​","type":1,"pageTitle":"页面布局","url":"/touying/zh/docs/layout#页面分栏","content":" 如果你需要将页面分为两栏或三栏，你可以使用 Touying slide 函数默认提供的 compose 功能，最简单的示例如下：  #slide[ First column. ][ Second column. ]     如果你需要更改分栏的方式，可以修改 slide 的 composer 参数，其中默认的参数是 utils.side-by-side.with(columns: auto, gutter: 1em)，如果我们要让左边那一栏占据剩余宽度，可以使用  #slide(composer: (1fr, auto))[ First column. ][ Second column. ]    ","version":"0.4.2","tagName":"h2"},{"title":"Touying 的 Sections","type":0,"sectionRef":"#","url":"/touying/zh/docs/progress/sections","content":"","keywords":"","version":"0.4.2"},{"title":"touying-outline​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/progress/sections#touying-outline","content":" #touying-outline(enum-args: (:), padding: 0pt) 用于显示一个简单的大纲。  当然，你现在也可以直接使用 #outline(indent: 2em, title: none)。  ","version":"0.4.2","tagName":"h2"},{"title":"touying-final-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/progress/sections#touying-final-sections","content":" #states.touying-final-sections(final-sections =&gt; ..) 用于自定义显示大纲。  ","version":"0.4.2","tagName":"h2"},{"title":"touying-progress-with-sections​","type":1,"pageTitle":"Touying 的 Sections","url":"/touying/zh/docs/progress/sections#touying-progress-with-sections","content":" #states.touying-progress-with-sections((current-sections: .., final-sections: .., current-slide-number: .., last-slide-number: ..) =&gt; ..)   功能最强大，你可以用其搭建任意复杂的进度展示。 ","version":"0.4.2","tagName":"h2"},{"title":"节与小节","type":0,"sectionRef":"#","url":"/touying/zh/docs/sections","content":"","keywords":"","version":"0.4.2"},{"title":"结构​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/sections#结构","content":" 与 Beamer 相同，Touying 同样有着 section 和 subsection 的概念。  一般而言，1 级、2 级和 3 级标题分别用来对应 section、subsection 和 title，例如 dewdrop 主题。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Subsection === Title Hello, Touying!     但是很多时候我们并不需要 subsection，因此也会使用 1 级和 2 级标题来分别对应 section 和 title，例如 university 主题。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register() #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides = Section == Title Hello, Touying!     实际上，我们可以通过 slides 函数的 slide-level 参数来控制这里的行为。slide-level 代表着嵌套结构的复杂度，从 0 开始计算。例如 #show: slides.with(slide-level: 2) 等价于 section，subsection 和 title 结构；而 #show: slides.with(slide-level: 1) 等价于 section 和 title 结构。  ","version":"0.4.2","tagName":"h2"},{"title":"编号​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/sections#编号","content":" 为了给节与小节加入编号，我们只需要使用  #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;)   即可设置默认编号为 1.1，且 section 对应的编号为 1.。  ","version":"0.4.2","tagName":"h2"},{"title":"目录​","type":1,"pageTitle":"节与小节","url":"/touying/zh/docs/sections#目录","content":" 在 Touying 中显示目录很简单：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register() #let (init, slides, alert, touying-outline) = utils.methods(s) #show: init #let (slide, empty-slide) = utils.slides(s) #show: slides.with(slide-level: 2) = Section == Subsection === Title ==== Table of contents #touying-outline()     其中 touying-oultine() 的定义为：  #let touying-outline(enum-args: (:), padding: 0pt) = { .. }   你可以通过 enum-args 修改内部 enum 的参数。  你当然也可以使用 Typst 原生的目录：  #outline(title: none, indent: 2em)     如果你对目录有着复杂的自定义需求，你可以使用  #states.touying-final-sections(sections =&gt; ..)   正如 dewdrop 主题所做的那样。 ","version":"0.4.2","tagName":"h2"},{"title":"开始","type":0,"sectionRef":"#","url":"/touying/zh/docs/start","content":"","keywords":"","version":"0.4.2"},{"title":"更复杂的例子​","type":1,"pageTitle":"开始","url":"/touying/zh/docs/start#更复杂的例子","content":" 事实上，Touying 提供了多种 slides 编写风格，实际上您也可以使用 #slide[..] 的写法，以获得 Touying 提供的更多更强大的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #import &quot;@preview/cetz:0.2.2&quot; #import &quot;@preview/fletcher:0.4.4&quot; as fletcher: node, edge #import &quot;@preview/ctheorems:1.1.2&quot;: * // cetz and fletcher bindings for touying #let cetz-canvas = touying-reducer.with(reduce: cetz.canvas, cover: cetz.draw.hide.with(bounds: true)) #let fletcher-diagram = touying-reducer.with(reduce: fletcher.diagram, cover: fletcher.hide) // Register university theme // You can replace it with other themes and it can still work normally #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) // Set the numbering of section and subsection #let s = (s.methods.numbering)(self: s, section: &quot;1.&quot;, &quot;1.1&quot;) // Set the speaker notes configuration // #let s = (s.methods.show-notes-on-second-screen)(self: s, right) // Global information configuration #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) // Pdfpc configuration // typst query --root . ./example.typ --field value --one &quot;&lt;pdfpc-file&gt;&quot; &gt; ./example.pdfpc #let s = (s.methods.append-preamble)(self: s, pdfpc.config( duration-minutes: 30, start-time: datetime(hour: 14, minute: 10, second: 0), end-time: datetime(hour: 14, minute: 40, second: 0), last-minutes: 5, note-font-size: 12, disable-markdown: false, default-transition: ( type: &quot;push&quot;, duration-seconds: 2, angle: ltr, alignment: &quot;vertical&quot;, direction: &quot;inward&quot;, ), )) // Theroems configuration by ctheorems #show: thmrules.with(qed-symbol: $square$) #let theorem = thmbox(&quot;theorem&quot;, &quot;Theorem&quot;, fill: rgb(&quot;#eeffee&quot;)) #let corollary = thmplain( &quot;corollary&quot;, &quot;Corollary&quot;, base: &quot;theorem&quot;, titlefmt: strong ) #let definition = thmbox(&quot;definition&quot;, &quot;Definition&quot;, inset: (x: 1.2em, top: 1em)) #let example = thmplain(&quot;example&quot;, &quot;Example&quot;).with(numbering: none) #let proof = thmproof(&quot;proof&quot;, &quot;Proof&quot;) // Extract methods #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert // Extract slide functions #let (slide, empty-slide) = utils.slides(s) #show: slides = Animation == Simple Animation We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. #speaker-note[ + This is a speaker note. + You won't see it unless you use `#let s = (s.math.show-notes-on-second-screen)(self: s, right)` ] == Complex Animation - Mark-Style At subslide #utils.touying-wrapper((self: none) =&gt; str(self.subslide)), we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. == Complex Animation - Callback-Style #slide(repeat: 3, self =&gt; [ #let (uncover, only, alternatives) = utils.methods(self) At subslide #self.subslide, we can use #uncover(&quot;2-&quot;)[`#uncover` function] for reserving space, use #only(&quot;2-&quot;)[`#only` function] for not reserving space, #alternatives[call `#only` multiple times \\u{2717}][use `#alternatives` function #sym.checkmark] for choosing one of the alternatives. ]) == Math Equation Animation Touying equation with `pause`: #touying-equation(` f(x) &amp;= pause x^2 + 2x + 1 \\ &amp;= pause (x + 1)^2 \\ `) #meanwhile Here, #pause we have the expression of $f(x)$. #pause By factorizing, we can obtain this result. == CeTZ Animation CeTZ Animation in Touying: #cetz-canvas({ import cetz.draw: * rect((0,0), (5,5)) (pause,) rect((0,0), (1,1)) rect((1,1), (2,2)) rect((2,2), (3,3)) (pause,) line((0,0), (2.5, 2.5), name: &quot;line&quot;) }) == Fletcher Animation Fletcher Animation in Touying: #fletcher-diagram( node-stroke: .1em, node-fill: gradient.radial(blue.lighten(80%), blue, center: (30%, 20%), radius: 80%), spacing: 4em, edge((-1,0), &quot;r&quot;, &quot;-|&gt;&quot;, `open(path)`, label-pos: 0, label-side: center), node((0,0), `reading`, radius: 2em), edge((0,0), (0,0), `read()`, &quot;--|&gt;&quot;, bend: 130deg), pause, edge(`read()`, &quot;-|&gt;&quot;), node((1,0), `eof`, radius: 2em), pause, edge(`close()`, &quot;-|&gt;&quot;), node((2,0), `closed`, radius: 2em, extrude: (-2.5, 0)), edge((0,0), (2,0), `close()`, &quot;-|&gt;&quot;, bend: -40deg), ) = Theroems == Prime numbers #definition[ A natural number is called a #highlight[_prime number_] if it is greater than 1 and cannot be written as the product of two smaller natural numbers. ] #example[ The numbers $2$, $3$, and $17$ are prime. @cor_largest_prime shows that this list is not exhaustive! ] #theorem(&quot;Euclid&quot;)[ There are infinitely many primes. ] #proof[ Suppose to the contrary that $p_1, p_2, dots, p_n$ is a finite enumeration of all primes. Set $P = p_1 p_2 dots p_n$. Since $P + 1$ is not in our list, it cannot be prime. Thus, some prime factor $p_j$ divides $P + 1$. Since $p_j$ also divides $P$, it must divide the difference $(P + 1) - P = 1$, a contradiction. ] #corollary[ There is no largest prime number. ] &lt;cor_largest_prime&gt; #corollary[ There are infinitely many composite numbers. ] #theorem[ There are arbitrarily long stretches of composite numbers. ] #proof[ For any $n &gt; 2$, consider $ n! + 2, quad n! + 3, quad ..., quad n! + n #qedhere $ ] = Others == Side-by-side #slide(composer: (1fr, 1fr))[ First column. ][ Second column. ] == Multiple Pages #lorem(200) // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) == Appendix #slide[ Please pay attention to the current slide number. ]     Touying 提供了很多内置的主题，能够简单地编写精美的 slides，例如此处的  #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;)   可以使用 university 主题。关于主题更详细的教程，您可以参阅后面的章节。 ","version":"0.4.2","tagName":"h2"},{"title":"Dewdrop 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/themes/dewdrop","content":"","keywords":"","version":"0.4.2"},{"title":"初始化​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: &quot;sidebar&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。navigation: 导航栏样式，可以是 &quot;sidebar&quot;、&quot;mini-slides&quot; 和 none，默认为 &quot;sidebar&quot;。sidebar: 侧边导航栏设置，默认为 (width: 10em)。mini-slides: mini-slides 设置，默认为 (height: 2em, x: 2em, section: false, subsection: true)。 height: mini-slides 高度，默认为 2em。x: mini-slides 的 x 轴 padding，默认为 2em。section: 是否显示 section 之后，subsection 之前的 slides，默认为 false。subsection: 是否根据 subsection 分割 mini-slides，设置为 false 挤压为一行，默认为 true。 footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。primary: primary 颜色，默认为 rgb(&quot;#0c4842&quot;)。alpha: 透明度，默认为 70%。  并且 Dewdrop 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.2","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#颜色主题","content":" Dewdrop 默认使用了  #let s = (s.methods.colors)( self: s, neutral-darkest: rgb(&quot;#000000&quot;), neutral-dark: rgb(&quot;#202020&quot;), neutral-light: rgb(&quot;#f3f3f3&quot;), neutral-lightest: rgb(&quot;#ffffff&quot;), primary: primary, )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.2","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#slide-函数族","content":" Dewdrop 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Dewdrop theme footer: auto, )[ ... ]   默认拥有导航栏和页脚的普通 slide 函数，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。  ","version":"0.4.2","tagName":"h2"},{"title":"特殊函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#特殊函数","content":" #d-outline(enum-args: (:), list-args: (:), cover: true)   显示当前的目录，cover 参数用于指定是否要隐藏处于 inactive 状态的 sections。    #d-sidebar()   内部函数，用于显示侧边栏。    #d-mini-slides()   内部函数，用于显示 mini-slides。  ","version":"0.4.2","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 2。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register(aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop]) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.2","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Dewdrop 主题","url":"/touying/zh/docs/themes/dewdrop#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.dewdrop.register( aspect-ratio: &quot;16-9&quot;, footer: [Dewdrop], navigation: &quot;mini-slides&quot;, // navigation: none, ) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = Section A == Subsection A.1 #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ ] == Subsection A.2 #slide[ A slide without a title but with *important* infos ] = Section B == Subsection B.1 #slide[ #lorem(80) ] #focus-slide[ Wake up! ] == Subsection B.2 #slide[ We can use `#pause` to #pause display something later. #pause Just like this. #meanwhile Meanwhile, #pause we can also use `#meanwhile` to #pause display other content synchronously. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix === Appendix #slide[ Please pay attention to the current slide number. ]  ","version":"0.4.2","tagName":"h2"},{"title":"Aqua 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/themes/aqua","content":"","keywords":"","version":"0.4.2"},{"title":"初始化​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/themes/aqua#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚右侧的内容，默认为 states.slide-counter.display()。lang: 语言配置，目前只支持 &quot;en&quot; 和 &quot;zh&quot;，默认为 &quot;en&quot;,  并且 Aqua 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.2","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/themes/aqua#颜色主题","content":" Aqua 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#003F88&quot;), primary-light: rgb(&quot;#2159A5&quot;), primary-lightest: rgb(&quot;#F2F4F8&quot;),   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.2","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/themes/aqua#slide-函数族","content":" Aqua 主题提供了一系列自定义 slide 函数：  #title-slide(..args)   title-slide 会读取 self.info 里的信息用于显示。    #let outline-slide(self: none, enum-args: (:), leading: 50pt)   显示一个大纲页。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // Aqua theme title: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary。    #new-section-slide(title)   用给定标题开启一个新的 section。  ","version":"0.4.2","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/themes/aqua#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.2","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Aqua 主题","url":"/touying/zh/docs/themes/aqua#示例","content":" #import &quot;../lib.typ&quot;: * #let s = themes.aqua.register(aspect-ratio: &quot;16-9&quot;, lang: &quot;en&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, outline-slide, focus-slide) = utils.slides(s) #show: slides = The Section == Slide Title #slide[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] == Summary #align(center + horizon)[ #set text(size: 3em, weight: &quot;bold&quot;, s.colors.primary) THANKS FOR ALL ]  ","version":"0.4.2","tagName":"h2"},{"title":"Metropolis 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/themes/metropolis","content":"","keywords":"","version":"0.4.2"},{"title":"初始化​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/themes/metropolis#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。header: 显示在页眉的内容，默认为 states.current-section-title，也可以传入形如 self =&gt; self.info.title 的函数。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。footer-progress: 是否显示 slide 底部的进度条，默认为 true。  并且 Metropolis 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.2","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/themes/metropolis#颜色主题","content":" Metropolis 默认使用了  #let s = (s.methods.colors)( self: s, neutral-lightest: rgb(&quot;#fafafa&quot;), primary-dark: rgb(&quot;#23373b&quot;), secondary-light: rgb(&quot;#eb811b&quot;), secondary-lighter: rgb(&quot;#d6c6b7&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.2","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/themes/metropolis#slide-函数族","content":" Metropolis 主题提供了一系列自定义 slide 函数：  #title-slide(extra: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 extra 参数，显示额外的信息。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // metropolis theme title: auto, footer: auto, align: horizon, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide[ ... ]   用于引起观众的注意力。背景色为 self.colors.primary-dark。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。  ","version":"0.4.2","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/themes/metropolis#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。outline-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  PS: 其中 outline title 可以通过 #(s.outline-title = [Outline]) 的方式修改。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slide, slides, title-slide, new-section-slide, focus-slide, touying-outline, alert) = utils.methods(s) #show: init #show strong: alert #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.2","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Metropolis 主题","url":"/touying/zh/docs/themes/metropolis#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.metropolis.register(aspect-ratio: &quot;16-9&quot;, footer: self =&gt; self.info.institution) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #set text(font: &quot;Fira Sans&quot;, weight: &quot;light&quot;, size: 20pt) #show math.equation: set text(font: &quot;Fira Math&quot;) #set strong(delta: 100) #set par(justify: true) #show strong: alert #let (slide, empty-slide, title-slide, new-section-slide, focus-slide) = utils.slides(s) #show: slides = First Section #slide[ A slide without a title but with some *important* information. ] == A long long long long long long long long long long long long long long long long long long long long long long long long Title #slide[ A slide with equation: $ x_(n+1) = (x_n + a/x_n) / 2 $ #lorem(200) ] = Second Section #focus-slide[ Wake up! ] == Simple Animation #slide[ A simple #pause dynamic slide with #alert[alert] #pause text. ] // appendix by freezing last-slide-number #let s = (s.methods.appendix)(self: s) #let (slide, empty-slide) = utils.slides(s) = Appendix #slide[ Appendix. ]  ","version":"0.4.2","tagName":"h2"},{"title":"Simple 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/themes/simple","content":"","keywords":"","version":"0.4.2"},{"title":"初始化​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/themes/simple#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。footer: 展示在页脚的内容，默认为 []，也可以传入形如 self =&gt; self.info.author 的函数。footer-right: 展示在页脚右侧的内容，默认为 states.slide-counter.display() + &quot; / &quot; + states.last-slide-number。background: 背景颜色，默认为白色。foreground: 文本颜色，默认为黑色。primary: 主题颜色，默认为 aqua.darken(50%)。  ","version":"0.4.2","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/themes/simple#slide-函数族","content":" simple 主题提供了一系列自定义 slide 函数：  #centered-slide(section: ..)[ ... ]   内容位于幻灯片中央的幻灯片，section 参数可以用于新建一个 section。    #title-slide[ ... ]   和 centered-slide 相同，这里只是为了保持和 Polylux 语法上的一致性。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // simple theme args footer: auto, )[ ... ]   默认拥有页眉和页脚的普通 slide 函数，其中页眉为当前 section，页脚为您设置的页脚。    #focus-slide(foreground: ..., background: ...)[ ... ]   用于引起观众的注意力。可选接受一个前景色 (默认为 white) 和一个背景色 (默认为 auto，即 self.colors.primary)。  ","version":"0.4.2","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/themes/simple#slides-函数","content":" slides 函数拥有参数  slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let s = (s.methods.enable-transparent-cover)(self: s) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.2","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"Simple 主题","url":"/touying/zh/docs/themes/simple#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.simple.register(aspect-ratio: &quot;16-9&quot;, footer: [Simple slides]) #let (init, slides) = utils.methods(s) #show: init #let (slide, empty-slide, title-slide, centered-slide, focus-slide) = utils.slides(s) #show: slides #title-slide[ = Keep it simple! #v(2em) Alpha #footnote[Uni Augsburg] #h(1em) Bravo #footnote[Uni Bayreuth] #h(1em) Charlie #footnote[Uni Chemnitz] #h(1em) July 23 ] == First slide #slide[ #lorem(20) ] #focus-slide[ _Focus!_ This is very important. ] = Let's start a new section! == Dynamic slide #slide[ Did you know that... #pause ...you can see the current section at the top of the slide? ]  ","version":"0.4.2","tagName":"h2"},{"title":"Fit to height / width","type":0,"sectionRef":"#","url":"/touying/zh/docs/utilities/fit-to","content":"","keywords":"","version":"0.4.2"},{"title":"Fit to height​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/utilities/fit-to#fit-to-height","content":" 如果你需要将图片占满剩余的 slide 高度，你可以来试试 fit-to-height 函数：  #utils.fit-to-height(1fr)[BIG]   函数定义：  #let fit-to-height( width: none, prescale-width: none, grow: true, shrink: true, height, body ) = { .. }   参数：  width: 如果指定，这将确定缩放后内容的宽度。因此，如果您希望缩放的内容填充幻灯片宽度的一半，则可以使用 width: 50%。prescale-width: 此参数允许您使 Typst 的布局假设给定的内容在缩放之前要布局在一定宽度的容器中。例如，您可以使用 prescale-width: 200% 假设幻灯片的宽度为原来的两倍。grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。height: 需要指定的高度。body: 具体的内容。  ","version":"0.4.2","tagName":"h2"},{"title":"Fit to width​","type":1,"pageTitle":"Fit to height / width","url":"/touying/zh/docs/utilities/fit-to#fit-to-width","content":" 如果你需要限制标题宽度刚好占满 slide 的宽度，你可以来试试 fit-to-width 函数：  #utils.fit-to-width(1fr)[#lorem(20)]   函数定义：  #let fit-to-width(grow: true, shrink: true, width, body) = { .. }   参数：  grow: 是否可扩张，默认为 true。shrink: 是否可收缩，默认为 true。width: 需要指定的宽度。body: 具体的内容。 ","version":"0.4.2","tagName":"h2"},{"title":"面向对象编程","type":0,"sectionRef":"#","url":"/touying/zh/docs/utilities/oop","content":"面向对象编程 Touying 提供了一些便利的工具函数，便于进行面向对象编程。 #let call-or-display(self, it) = { if type(it) == function { return it(self) } else { return it } } 调用或原样输出。 #let methods(self) = { .. } 用于为方法绑定 self 并返回，十分常用。","keywords":"","version":"0.4.2"},{"title":"University 主题","type":0,"sectionRef":"#","url":"/touying/zh/docs/themes/university","content":"","keywords":"","version":"0.4.2"},{"title":"初始化​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/themes/university#初始化","content":" 你可以通过下面的代码来初始化：  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides   其中 register 接收参数:  aspect-ratio: 幻灯片的长宽比为 &quot;16-9&quot; 或 &quot;4-3&quot;，默认为 &quot;16-9&quot;。progress-bar: 是否显示 slide 顶部的进度条，默认为 true。display-current-section: 是否显示当前节标题。footer-columns: 底部三栏 Footer 的宽度，默认为 (25%, 1fr, 25%)。footer-a: 第一栏，默认为 self =&gt; self.info.author。footer-b: 第二栏，默认为 self =&gt; if self.info.short-title == auto { self.info.title } else { self.info.short-title }。footer-c: 第三栏，默认为  self =&gt; { h(1fr) utils.info-date(self) h(1fr) states.slide-counter.display() + &quot; / &quot; + states.last-slide-number h(1fr) }   并且 University 主题会提供一个 #alert[..] 函数，你可以通过 #show strong: alert 来使用 *alert text* 语法。  ","version":"0.4.2","tagName":"h2"},{"title":"颜色主题​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/themes/university#颜色主题","content":" University 默认使用了  #let s = (s.methods.colors)( self: s, primary: rgb(&quot;#04364A&quot;), secondary: rgb(&quot;#176B87&quot;), tertiary: rgb(&quot;#448C95&quot;), )   颜色主题，你可以通过 #let s = (s.methods.colors)(self: s, ..) 对其进行修改。  ","version":"0.4.2","tagName":"h2"},{"title":"slide 函数族​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/themes/university#slide-函数族","content":" University 主题提供了一系列自定义 slide 函数：  #title-slide(logo: none, authors: none, ..args)   title-slide 会读取 self.info 里的信息用于显示，你也可以为其传入 logo 参数和 array 类型的 authors 参数。    #slide( repeat: auto, setting: body =&gt; body, composer: utils.side-by-side, section: none, subsection: none, // university theme title: none, subtitle: none, header: none, footer: auto, )[ ... ]   默认拥有标题和页脚的普通 slide 函数，其中 title 默认为当前 section title，页脚为您设置的页脚。    #focus-slide(background-img: ..., background-color: ...)[ ... ]   用于引起观众的注意力。默认背景色为 self.colors.primary。    #new-section-slide(short-title: auto, title)   用给定标题开启一个新的 section。    #matrix-slide(columns: ..., rows: ...)[ ... ][ ... ]   可以参考 文档。  ","version":"0.4.2","tagName":"h2"},{"title":"slides 函数​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/themes/university#slides-函数","content":" slides 函数拥有参数  title-slide: 默认为 true。slide-level: 默认为 1。  可以通过 #show: slides.with(..) 的方式设置。  以及可以通过 #(s.methods.touying-new-section-slide = none) 的方式关闭自动加入 new-section-slide 的功能。  #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides = Title == First Slide Hello, Touying! #pause Hello, Typst!     ","version":"0.4.2","tagName":"h2"},{"title":"示例​","type":1,"pageTitle":"University 主题","url":"/touying/zh/docs/themes/university#示例","content":" #import &quot;@preview/touying:0.4.2&quot;: * #let s = themes.university.register(aspect-ratio: &quot;16-9&quot;) #let s = (s.methods.info)( self: s, title: [Title], subtitle: [Subtitle], author: [Authors], date: datetime.today(), institution: [Institution], ) #let (init, slides, touying-outline, alert, speaker-note) = utils.methods(s) #show: init #show strong: alert #let (slide, empty-slide, title-slide, focus-slide, matrix-slide) = utils.slides(s) #show: slides.with(title-slide: false) #title-slide(authors: ([Author A], [Author B])) = The Section == Slide Title #slide[ #lorem(40) ] #slide(subtitle: emph[What is the problem?])[ #lorem(40) ] #focus-slide[ Another variant with primary color in background... ] #matrix-slide[ left ][ middle ][ right ] #matrix-slide(columns: 1)[ top ][ bottom ] #matrix-slide(columns: (1fr, 2fr, 1fr), ..(lorem(8),) * 9)  ","version":"0.4.2","tagName":"h2"}],"options":{"languages":["en","zh"],"id":"default"}}